; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_tim.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\User_App -I..\..\User\User_Driver -I..\..\User\Font_And_Bmp -I..\..\User\User_GUI -I..\..\User\Util -I.\RTE\_FreeRTOS_STM32F1 -I"D:\Keil MDK\ARM\PACK\ARM\CMSIS\5.5.1\CMSIS\Core\Include" -I"D:\Keil MDK\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=528 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\stm32f10x_tim.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=2

                  TI1_Config PROC
;;;2706     */
;;;2707   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;2708                          uint16_t TIM_ICFilter)
;;;2709   {
;;;2710     uint16_t tmpccmr1 = 0, tmpccer = 0;
;;;2711     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2712     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  8404              STRH     r4,[r0,#0x20]
;;;2713     tmpccmr1 = TIMx->CCMR1;
00000a  8b05              LDRH     r5,[r0,#0x18]
;;;2714     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;2715     /* Select the Input and set the filter */
;;;2716     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
00000e  f02505f3          BIC      r5,r5,#0xf3
;;;2717     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
000012  f64f76ff          MOV      r6,#0xffff
000016  ea061303          AND      r3,r6,r3,LSL #4
00001a  4313              ORRS     r3,r3,r2
00001c  432b              ORRS     r3,r3,r5
;;;2718     
;;;2719     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
00001e  4a10              LDR      r2,|L1.96|
000020  4290              CMP      r0,r2
000022  d00e              BEQ      |L1.66|
000024  4a0f              LDR      r2,|L1.100|
000026  4290              CMP      r0,r2
000028  d00b              BEQ      |L1.66|
00002a  f1b04f80          CMP      r0,#0x40000000
00002e  d008              BEQ      |L1.66|
000030  4a0d              LDR      r2,|L1.104|
000032  4290              CMP      r0,r2
000034  d005              BEQ      |L1.66|
;;;2720        (TIMx == TIM4) ||(TIMx == TIM5))
000036  4a0d              LDR      r2,|L1.108|
000038  4290              CMP      r0,r2
00003a  d002              BEQ      |L1.66|
00003c  4a0c              LDR      r2,|L1.112|
00003e  4290              CMP      r0,r2
000040  d105              BNE      |L1.78|
                  |L1.66|
;;;2721     {
;;;2722       /* Select the Polarity and set the CC1E Bit */
;;;2723       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
000042  f0240202          BIC      r2,r4,#2
;;;2724       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000046  430a              ORRS     r2,r2,r1
000048  f0420101          ORR      r1,r2,#1
00004c  e004              B        |L1.88|
                  |L1.78|
;;;2725     }
;;;2726     else
;;;2727     {
;;;2728       /* Select the Polarity and set the CC1E Bit */
;;;2729       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
00004e  f024020a          BIC      r2,r4,#0xa
;;;2730       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000052  430a              ORRS     r2,r2,r1
000054  f0420101          ORR      r1,r2,#1
                  |L1.88|
;;;2731     }
;;;2732   
;;;2733     /* Write to TIMx CCMR1 and CCER registers */
;;;2734     TIMx->CCMR1 = tmpccmr1;
000058  8303              STRH     r3,[r0,#0x18]
;;;2735     TIMx->CCER = tmpccer;
00005a  8401              STRH     r1,[r0,#0x20]
;;;2736   }
00005c  bd70              POP      {r4-r6,pc}
;;;2737   
                          ENDP

00005e  0000              DCW      0x0000
                  |L1.96|
                          DCD      0x40012c00
                  |L1.100|
                          DCD      0x40013400
                  |L1.104|
                          DCD      0x40000400
                  |L1.108|
                          DCD      0x40000800
                  |L1.112|
                          DCD      0x40000c00

                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=2

                  TI2_Config PROC
;;;2753     */
;;;2754   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2755                          uint16_t TIM_ICFilter)
;;;2756   {
;;;2757     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;2758     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2759     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  8404              STRH     r4,[r0,#0x20]
;;;2760     tmpccmr1 = TIMx->CCMR1;
00000a  8b06              LDRH     r6,[r0,#0x18]
;;;2761     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;2762     tmp = (uint16_t)(TIM_ICPolarity << 4);
00000e  f64f75ff          MOV      r5,#0xffff
000012  ea051701          AND      r7,r5,r1,LSL #4
;;;2763     /* Select the Input and set the filter */
;;;2764     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
000016  f4264673          BIC      r6,r6,#0xf300
;;;2765     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00001a  ea053303          AND      r3,r5,r3,LSL #12
00001e  4333              ORRS     r3,r3,r6
;;;2766     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000020  ea052202          AND      r2,r5,r2,LSL #8
000024  431a              ORRS     r2,r2,r3
;;;2767     
;;;2768     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000026  4b10              LDR      r3,|L2.104|
000028  4298              CMP      r0,r3
00002a  d00e              BEQ      |L2.74|
00002c  4b0f              LDR      r3,|L2.108|
00002e  4298              CMP      r0,r3
000030  d00b              BEQ      |L2.74|
000032  f1b04f80          CMP      r0,#0x40000000
000036  d008              BEQ      |L2.74|
000038  4b0d              LDR      r3,|L2.112|
00003a  4298              CMP      r0,r3
00003c  d005              BEQ      |L2.74|
;;;2769        (TIMx == TIM4) ||(TIMx == TIM5))
00003e  4b0d              LDR      r3,|L2.116|
000040  4298              CMP      r0,r3
000042  d002              BEQ      |L2.74|
000044  4b0c              LDR      r3,|L2.120|
000046  4298              CMP      r0,r3
000048  d105              BNE      |L2.86|
                  |L2.74|
;;;2770     {
;;;2771       /* Select the Polarity and set the CC2E Bit */
;;;2772       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
00004a  f0240120          BIC      r1,r4,#0x20
;;;2773       tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
00004e  4339              ORRS     r1,r1,r7
000050  f0410110          ORR      r1,r1,#0x10
000054  e004              B        |L2.96|
                  |L2.86|
;;;2774     }
;;;2775     else
;;;2776     {
;;;2777       /* Select the Polarity and set the CC2E Bit */
;;;2778       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
000056  f02403a0          BIC      r3,r4,#0xa0
;;;2779       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
00005a  430b              ORRS     r3,r3,r1
00005c  f0430110          ORR      r1,r3,#0x10
                  |L2.96|
;;;2780     }
;;;2781     
;;;2782     /* Write to TIMx CCMR1 and CCER registers */
;;;2783     TIMx->CCMR1 = tmpccmr1 ;
000060  8302              STRH     r2,[r0,#0x18]
;;;2784     TIMx->CCER = tmpccer;
000062  8401              STRH     r1,[r0,#0x20]
;;;2785   }
000064  bdf0              POP      {r4-r7,pc}
;;;2786   
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      0x40012c00
                  |L2.108|
                          DCD      0x40013400
                  |L2.112|
                          DCD      0x40000400
                  |L2.116|
                          DCD      0x40000800
                  |L2.120|
                          DCD      0x40000c00

                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=2

                  TI3_Config PROC
;;;2802     */
;;;2803   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2804                          uint16_t TIM_ICFilter)
;;;2805   {
;;;2806     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
;;;2807     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2808     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f4247480          BIC      r4,r4,#0x100
000008  8404              STRH     r4,[r0,#0x20]
;;;2809     tmpccmr2 = TIMx->CCMR2;
00000a  8b85              LDRH     r5,[r0,#0x1c]
;;;2810     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;2811     tmp = (uint16_t)(TIM_ICPolarity << 8);
00000e  f64f77ff          MOV      r7,#0xffff
000012  ea072601          AND      r6,r7,r1,LSL #8
;;;2812     /* Select the Input and set the filter */
;;;2813     tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
000016  f02505f3          BIC      r5,r5,#0xf3
;;;2814     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00001a  ea071303          AND      r3,r7,r3,LSL #4
00001e  4313              ORRS     r3,r3,r2
000020  432b              ORRS     r3,r3,r5
;;;2815       
;;;2816     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000022  4a10              LDR      r2,|L3.100|
000024  4290              CMP      r0,r2
000026  d00e              BEQ      |L3.70|
000028  4a0f              LDR      r2,|L3.104|
00002a  4290              CMP      r0,r2
00002c  d00b              BEQ      |L3.70|
00002e  f1b04f80          CMP      r0,#0x40000000
000032  d008              BEQ      |L3.70|
000034  4a0d              LDR      r2,|L3.108|
000036  4290              CMP      r0,r2
000038  d005              BEQ      |L3.70|
;;;2817        (TIMx == TIM4) ||(TIMx == TIM5))
00003a  4a0d              LDR      r2,|L3.112|
00003c  4290              CMP      r0,r2
00003e  d002              BEQ      |L3.70|
000040  4a0c              LDR      r2,|L3.116|
000042  4290              CMP      r0,r2
000044  d105              BNE      |L3.82|
                  |L3.70|
;;;2818     {
;;;2819       /* Select the Polarity and set the CC3E Bit */
;;;2820       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
000046  f4247100          BIC      r1,r4,#0x200
;;;2821       tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
00004a  4331              ORRS     r1,r1,r6
00004c  f4417180          ORR      r1,r1,#0x100
000050  e004              B        |L3.92|
                  |L3.82|
;;;2822     }
;;;2823     else
;;;2824     {
;;;2825       /* Select the Polarity and set the CC3E Bit */
;;;2826       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
000052  f4246220          BIC      r2,r4,#0xa00
;;;2827       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
000056  430a              ORRS     r2,r2,r1
000058  f4427180          ORR      r1,r2,#0x100
                  |L3.92|
;;;2828     }
;;;2829     
;;;2830     /* Write to TIMx CCMR2 and CCER registers */
;;;2831     TIMx->CCMR2 = tmpccmr2;
00005c  8383              STRH     r3,[r0,#0x1c]
;;;2832     TIMx->CCER = tmpccer;
00005e  8401              STRH     r1,[r0,#0x20]
;;;2833   }
000060  bdf0              POP      {r4-r7,pc}
;;;2834   
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
                          DCD      0x40012c00
                  |L3.104|
                          DCD      0x40013400
                  |L3.108|
                          DCD      0x40000400
                  |L3.112|
                          DCD      0x40000800
                  |L3.116|
                          DCD      0x40000c00

                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=2

                  TI4_Config PROC
;;;2850     */
;;;2851   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2852                          uint16_t TIM_ICFilter)
;;;2853   {
;;;2854     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
;;;2855   
;;;2856      /* Disable the Channel 4: Reset the CC4E Bit */
;;;2857     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f4245480          BIC      r4,r4,#0x1000
000008  8404              STRH     r4,[r0,#0x20]
;;;2858     tmpccmr2 = TIMx->CCMR2;
00000a  8b86              LDRH     r6,[r0,#0x1c]
;;;2859     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;2860     tmp = (uint16_t)(TIM_ICPolarity << 12);
00000e  f64f75ff          MOV      r5,#0xffff
000012  ea053701          AND      r7,r5,r1,LSL #12
;;;2861     /* Select the Input and set the filter */
;;;2862     tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
000016  f4264673          BIC      r6,r6,#0xf300
;;;2863     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
00001a  ea052202          AND      r2,r5,r2,LSL #8
00001e  4332              ORRS     r2,r2,r6
;;;2864     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
000020  ea053303          AND      r3,r5,r3,LSL #12
000024  4313              ORRS     r3,r3,r2
;;;2865     
;;;2866     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000026  4a10              LDR      r2,|L4.104|
000028  4290              CMP      r0,r2
00002a  d00e              BEQ      |L4.74|
00002c  4a0f              LDR      r2,|L4.108|
00002e  4290              CMP      r0,r2
000030  d00b              BEQ      |L4.74|
000032  f1b04f80          CMP      r0,#0x40000000
000036  d008              BEQ      |L4.74|
000038  4a0d              LDR      r2,|L4.112|
00003a  4290              CMP      r0,r2
00003c  d005              BEQ      |L4.74|
;;;2867        (TIMx == TIM4) ||(TIMx == TIM5))
00003e  4a0d              LDR      r2,|L4.116|
000040  4290              CMP      r0,r2
000042  d002              BEQ      |L4.74|
000044  4a0c              LDR      r2,|L4.120|
000046  4290              CMP      r0,r2
000048  d105              BNE      |L4.86|
                  |L4.74|
;;;2868     {
;;;2869       /* Select the Polarity and set the CC4E Bit */
;;;2870       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
00004a  f4245100          BIC      r1,r4,#0x2000
;;;2871       tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
00004e  4339              ORRS     r1,r1,r7
000050  f4415180          ORR      r1,r1,#0x1000
000054  e004              B        |L4.96|
                  |L4.86|
;;;2872     }
;;;2873     else
;;;2874     {
;;;2875       /* Select the Polarity and set the CC4E Bit */
;;;2876       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
000056  f4244202          BIC      r2,r4,#0x8200
;;;2877       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
00005a  430a              ORRS     r2,r2,r1
00005c  f4425180          ORR      r1,r2,#0x1000
                  |L4.96|
;;;2878     }
;;;2879     /* Write to TIMx CCMR2 and CCER registers */
;;;2880     TIMx->CCMR2 = tmpccmr2;
000060  8383              STRH     r3,[r0,#0x1c]
;;;2881     TIMx->CCER = tmpccer;
000062  8401              STRH     r1,[r0,#0x20]
;;;2882   }
000064  bdf0              POP      {r4-r7,pc}
;;;2883   
                          ENDP

000066  0000              DCW      0x0000
                  |L4.104|
                          DCD      0x40012c00
                  |L4.108|
                          DCD      0x40013400
                  |L4.112|
                          DCD      0x40000400
                  |L4.116|
                          DCD      0x40000800
                  |L4.120|
                          DCD      0x40000c00

                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1414     */
;;;1415   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1416   {
000002  d004              BEQ      |L5.14|
;;;1417     /* Check the parameters */
;;;1418     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1419     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1420     if (NewState != DISABLE)
;;;1421     {
;;;1422       /* Set the ARR Preload Bit */
;;;1423       TIMx->CR1 |= TIM_CR1_ARPE;
000004  8801              LDRH     r1,[r0,#0]
000006  f0410180          ORR      r1,r1,#0x80
00000a  8001              STRH     r1,[r0,#0]
;;;1424     }
;;;1425     else
;;;1426     {
;;;1427       /* Reset the ARR Preload Bit */
;;;1428       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
;;;1429     }
;;;1430   }
00000c  4770              BX       lr
                  |L5.14|
00000e  8801              LDRH     r1,[r0,#0]            ;1428
000010  f0210180          BIC      r1,r1,#0x80           ;1428
000014  8001              STRH     r1,[r0,#0]            ;1428
000016  4770              BX       lr
;;;1431   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;717      */
;;;718    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  b510              PUSH     {r4,lr}
;;;719    {
;;;720      /* Check the parameters */
;;;721      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;722      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;723      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;724      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;725      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;726      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;727      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;728      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;729         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;730      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  880a              LDRH     r2,[r1,#0]
000004  884b              LDRH     r3,[r1,#2]
000006  88cc              LDRH     r4,[r1,#6]
000008  431a              ORRS     r2,r2,r3
00000a  888b              LDRH     r3,[r1,#4]
00000c  4323              ORRS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  890b              LDRH     r3,[r1,#8]
000012  431a              ORRS     r2,r2,r3
000014  894b              LDRH     r3,[r1,#0xa]
000016  8989              LDRH     r1,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  430a              ORRS     r2,r2,r1
00001c  f8a02044          STRH     r2,[r0,#0x44]
;;;731                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;732                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;733                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;734    }
000020  bd10              POP      {r4,pc}
;;;735    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;792      */
;;;793    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;794    {
;;;795      /* Set the default configuration */
;;;796      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;797      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;798      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;799      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;800      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;801      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;802      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;803    }
000010  4770              BX       lr
;;;804    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1488     */
;;;1489   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1490   { 
000002  d004              BEQ      |L8.14|
;;;1491     /* Check the parameters */
;;;1492     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1493     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1494     if (NewState != DISABLE)
;;;1495     {
;;;1496       /* Set the CCPC Bit */
;;;1497       TIMx->CR2 |= TIM_CR2_CCPC;
000004  8881              LDRH     r1,[r0,#4]
000006  f0410101          ORR      r1,r1,#1
00000a  8081              STRH     r1,[r0,#4]
;;;1498     }
;;;1499     else
;;;1500     {
;;;1501       /* Reset the CCPC Bit */
;;;1502       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
;;;1503     }
;;;1504   }
00000c  4770              BX       lr
                  |L8.14|
00000e  8881              LDRH     r1,[r0,#4]            ;1502
000010  f0210101          BIC      r1,r1,#1              ;1502
000014  8081              STRH     r1,[r0,#4]            ;1502
000016  4770              BX       lr
;;;1505   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1979     */
;;;1980   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;1981   {
;;;1982     uint16_t tmp = 0;
;;;1983   
;;;1984     /* Check the parameters */
;;;1985     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1986     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1987     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1988   
;;;1989     tmp = CCER_CCE_Set << TIM_Channel;
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
;;;1990   
;;;1991     /* Reset the CCxE Bit */
;;;1992     TIMx->CCER &= (uint16_t)~ tmp;
000006  8c04              LDRH     r4,[r0,#0x20]
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;1993   
;;;1994     /* Set or reset the CCxE Bit */ 
;;;1995     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;1996   }
000014  bd10              POP      {r4,pc}
;;;1997   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2009     */
;;;2010   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;2011   {
;;;2012     uint16_t tmp = 0;
;;;2013   
;;;2014     /* Check the parameters */
;;;2015     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2016     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2017     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2018   
;;;2019     tmp = CCER_CCNE_Set << TIM_Channel;
000002  2304              MOVS     r3,#4
000004  408b              LSLS     r3,r3,r1
;;;2020   
;;;2021     /* Reset the CCxNE Bit */
;;;2022     TIMx->CCER &= (uint16_t) ~tmp;
000006  8c04              LDRH     r4,[r0,#0x20]
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;2023   
;;;2024     /* Set or reset the CCxNE Bit */ 
;;;2025     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;2026   }
000014  bd10              POP      {r4,pc}
;;;2027   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2605     */
;;;2606   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;2607   {  
;;;2608     /* Check the parameters */
;;;2609     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2610     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2611      
;;;2612     /* Clear the flags */
;;;2613     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8201              STRH     r1,[r0,#0x10]
;;;2614   }
000004  4770              BX       lr
;;;2615   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2681     */
;;;2682   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;2683   {
;;;2684     /* Check the parameters */
;;;2685     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2686     assert_param(IS_TIM_IT(TIM_IT));
;;;2687     /* Clear the IT pending Bit */
;;;2688     TIMx->SR = (uint16_t)~TIM_IT;
000002  8201              STRH     r1,[r0,#0x10]
;;;2689   }
000004  4770              BX       lr
;;;2690   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1712     */
;;;1713   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1714   {
;;;1715     uint16_t tmpccmr1 = 0;
;;;1716     /* Check the parameters */
;;;1717     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1718     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1719   
;;;1720     tmpccmr1 = TIMx->CCMR1;
;;;1721   
;;;1722     /* Reset the OC1CE Bit */
;;;1723     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1724     /* Enable or Disable the Output Compare Clear Bit */
;;;1725     tmpccmr1 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1726     /* Write to TIMx CCMR1 register */
;;;1727     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1728   }
00000a  4770              BX       lr
;;;1729   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1738     */
;;;1739   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1740   {
;;;1741     uint16_t tmpccmr1 = 0;
;;;1742     /* Check the parameters */
;;;1743     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1744     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1745     tmpccmr1 = TIMx->CCMR1;
;;;1746     /* Reset the OC2CE Bit */
;;;1747     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
000002  f3c2020e          UBFX     r2,r2,#0,#15
;;;1748     /* Enable or Disable the Output Compare Clear Bit */
;;;1749     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1750     /* Write to TIMx CCMR1 register */
;;;1751     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1752   }
000012  4770              BX       lr
;;;1753   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1762     */
;;;1763   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1764   {
;;;1765     uint16_t tmpccmr2 = 0;
;;;1766     /* Check the parameters */
;;;1767     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1768     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1769     tmpccmr2 = TIMx->CCMR2;
;;;1770     /* Reset the OC3CE Bit */
;;;1771     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1772     /* Enable or Disable the Output Compare Clear Bit */
;;;1773     tmpccmr2 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1774     /* Write to TIMx CCMR2 register */
;;;1775     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1776   }
00000a  4770              BX       lr
;;;1777   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1786     */
;;;1787   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1788   {
;;;1789     uint16_t tmpccmr2 = 0;
;;;1790     /* Check the parameters */
;;;1791     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1792     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1793     tmpccmr2 = TIMx->CCMR2;
;;;1794     /* Reset the OC4CE Bit */
;;;1795     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
000002  f3c2020e          UBFX     r2,r2,#0,#15
;;;1796     /* Enable or Disable the Output Compare Clear Bit */
;;;1797     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1798     /* Write to TIMx CCMR2 register */
;;;1799     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1800   }
000012  4770              BX       lr
;;;1801   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;811      */
;;;812    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;813    {
000002  d004              BEQ      |L17.14|
;;;814      /* Check the parameters */
;;;815      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;816      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;817      
;;;818      if (NewState != DISABLE)
;;;819      {
;;;820        /* Enable the TIM Counter */
;;;821        TIMx->CR1 |= TIM_CR1_CEN;
000004  8801              LDRH     r1,[r0,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  8001              STRH     r1,[r0,#0]
;;;822      }
;;;823      else
;;;824      {
;;;825        /* Disable the TIM Counter */
;;;826        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
;;;827      }
;;;828    }
00000c  4770              BX       lr
                  |L17.14|
00000e  8801              LDRH     r1,[r0,#0]            ;826
000010  f0210101          BIC      r1,r1,#1              ;826
000014  8001              STRH     r1,[r0,#0]            ;826
000016  4770              BX       lr
;;;829    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1204     */
;;;1205   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;1206   {
;;;1207     uint16_t tmpcr1 = 0;
;;;1208     /* Check the parameters */
;;;1209     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1210     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1211     tmpcr1 = TIMx->CR1;
;;;1212     /* Reset the CMS and DIR Bits */
;;;1213     tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000002  f0220270          BIC      r2,r2,#0x70
;;;1214     /* Set the Counter Mode */
;;;1215     tmpcr1 |= TIM_CounterMode;
000006  430a              ORRS     r2,r2,r1
;;;1216     /* Write to TIMx CR1 register */
;;;1217     TIMx->CR1 = tmpcr1;
000008  8002              STRH     r2,[r0,#0]
;;;1218   }
00000a  4770              BX       lr
;;;1219   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;836      */
;;;837    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;838    {
000002  d005              BEQ      |L19.16|
;;;839      /* Check the parameters */
;;;840      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;841      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;842      if (NewState != DISABLE)
;;;843      {
;;;844        /* Enable the TIM Main Output */
;;;845        TIMx->BDTR |= TIM_BDTR_MOE;
000004  f8301f44          LDRH     r1,[r0,#0x44]!
000008  f4414100          ORR      r1,r1,#0x8000
00000c  8001              STRH     r1,[r0,#0]
;;;846      }
;;;847      else
;;;848      {
;;;849        /* Disable the TIM Main Output */
;;;850        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
;;;851      }  
;;;852    }
00000e  4770              BX       lr
                  |L19.16|
000010  f8301f44          LDRH     r1,[r0,#0x44]!        ;850
000014  f3c1010e          UBFX     r1,r1,#0,#15          ;850
000018  8001              STRH     r1,[r0,#0]            ;850
00001a  4770              BX       lr
;;;853    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;969      */
;;;970    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;971    { 
000002  d003              BEQ      |L20.12|
;;;972      /* Check the parameters */
;;;973      assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;974      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;975      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;976      
;;;977      if (NewState != DISABLE)
;;;978      {
;;;979        /* Enable the DMA sources */
;;;980        TIMx->DIER |= TIM_DMASource; 
000004  8982              LDRH     r2,[r0,#0xc]
000006  430a              ORRS     r2,r2,r1
000008  8182              STRH     r2,[r0,#0xc]
;;;981      }
;;;982      else
;;;983      {
;;;984        /* Disable the DMA sources */
;;;985        TIMx->DIER &= (uint16_t)~TIM_DMASource;
;;;986      }
;;;987    }
00000a  4770              BX       lr
                  |L20.12|
00000c  8982              LDRH     r2,[r0,#0xc]          ;985
00000e  438a              BICS     r2,r2,r1              ;985
000010  8182              STRH     r2,[r0,#0xc]          ;985
000012  4770              BX       lr
;;;988    
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;942      */
;;;943    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;944    {
;;;945      /* Check the parameters */
;;;946      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;947      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;948      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;949      /* Set the DMA Base and the DMA Burst Length */
;;;950      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;951    }
000006  4770              BX       lr
;;;952    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;127      */
;;;128    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130      /* Check the parameters */
;;;131      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;132     
;;;133      if (TIMx == TIM1)
000002  4973              LDR      r1,|L22.464|
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L22.30|
;;;134      {
;;;135        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  14c4              ASRS     r4,r0,#19
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;136        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.30|
;;;137      }     
;;;138      else if (TIMx == TIM2)
00001e  f1b04f80          CMP      r0,#0x40000000
000022  d00c              BEQ      |L22.62|
;;;139      {
;;;140        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;141        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;142      }
;;;143      else if (TIMx == TIM3)
000024  496b              LDR      r1,|L22.468|
000026  4288              CMP      r0,r1
000028  d113              BNE      |L22.82|
;;;144      {
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00002a  2101              MOVS     r1,#1
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;146        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000032  2100              MOVS     r1,#0
000034  e8bd4010          POP      {r4,lr}
000038  2002              MOVS     r0,#2
00003a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.62|
00003e  2101              MOVS     r1,#1                 ;140
000040  4608              MOV      r0,r1                 ;140
000042  f7fffffe          BL       RCC_APB1PeriphResetCmd
000046  2100              MOVS     r1,#0                 ;141
000048  e8bd4010          POP      {r4,lr}               ;141
00004c  2001              MOVS     r0,#1                 ;141
00004e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.82|
;;;147      }
;;;148      else if (TIMx == TIM4)
000052  4961              LDR      r1,|L22.472|
000054  4288              CMP      r0,r1
000056  d109              BNE      |L22.108|
;;;149      {
;;;150        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2004              MOVS     r0,#4
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;151        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
000060  2100              MOVS     r1,#0
000062  e8bd4010          POP      {r4,lr}
000066  2004              MOVS     r0,#4
000068  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.108|
;;;152      } 
;;;153      else if (TIMx == TIM5)
00006c  495b              LDR      r1,|L22.476|
00006e  4288              CMP      r0,r1
000070  d109              BNE      |L22.134|
;;;154      {
;;;155        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000072  2101              MOVS     r1,#1
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;156        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00007a  2100              MOVS     r1,#0
00007c  e8bd4010          POP      {r4,lr}
000080  2008              MOVS     r0,#8
000082  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.134|
;;;157      } 
;;;158      else if (TIMx == TIM6)
000086  4956              LDR      r1,|L22.480|
000088  4288              CMP      r0,r1
00008a  d109              BNE      |L22.160|
;;;159      {
;;;160        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
00008c  2101              MOVS     r1,#1
00008e  2010              MOVS     r0,#0x10
000090  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;161        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000094  2100              MOVS     r1,#0
000096  e8bd4010          POP      {r4,lr}
00009a  2010              MOVS     r0,#0x10
00009c  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.160|
;;;162      } 
;;;163      else if (TIMx == TIM7)
0000a0  4950              LDR      r1,|L22.484|
0000a2  4288              CMP      r0,r1
0000a4  d109              BNE      |L22.186|
;;;164      {
;;;165        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
0000a6  2101              MOVS     r1,#1
0000a8  2020              MOVS     r0,#0x20
0000aa  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;166        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000ae  2100              MOVS     r1,#0
0000b0  e8bd4010          POP      {r4,lr}
0000b4  2020              MOVS     r0,#0x20
0000b6  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.186|
;;;167      } 
;;;168      else if (TIMx == TIM8)
0000ba  494b              LDR      r1,|L22.488|
0000bc  4288              CMP      r0,r1
0000be  d10a              BNE      |L22.214|
;;;169      {
;;;170        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000c0  1444              ASRS     r4,r0,#17
0000c2  2101              MOVS     r1,#1
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;171        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
0000ca  4620              MOV      r0,r4
0000cc  e8bd4010          POP      {r4,lr}
0000d0  2100              MOVS     r1,#0
0000d2  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.214|
;;;172      }
;;;173      else if (TIMx == TIM9)
0000d6  4945              LDR      r1,|L22.492|
0000d8  4288              CMP      r0,r1
0000da  d10a              BNE      |L22.242|
;;;174      {      
;;;175        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  04cc              LSLS     r4,r1,#19
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;176        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000e6  4620              MOV      r0,r4
0000e8  e8bd4010          POP      {r4,lr}
0000ec  2100              MOVS     r1,#0
0000ee  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.242|
;;;177       }  
;;;178      else if (TIMx == TIM10)
0000f2  493f              LDR      r1,|L22.496|
0000f4  4288              CMP      r0,r1
0000f6  d10a              BNE      |L22.270|
;;;179      {      
;;;180        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000f8  2101              MOVS     r1,#1
0000fa  050c              LSLS     r4,r1,#20
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;181        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
000102  4620              MOV      r0,r4
000104  e8bd4010          POP      {r4,lr}
000108  2100              MOVS     r1,#0
00010a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.270|
;;;182      }  
;;;183      else if (TIMx == TIM11) 
00010e  4939              LDR      r1,|L22.500|
000110  4288              CMP      r0,r1
000112  d10a              BNE      |L22.298|
;;;184      {     
;;;185        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
000114  2101              MOVS     r1,#1
000116  054c              LSLS     r4,r1,#21
000118  4620              MOV      r0,r4
00011a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;186        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
00011e  4620              MOV      r0,r4
000120  e8bd4010          POP      {r4,lr}
000124  2100              MOVS     r1,#0
000126  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.298|
;;;187      }  
;;;188      else if (TIMx == TIM12)
00012a  4933              LDR      r1,|L22.504|
00012c  4288              CMP      r0,r1
00012e  d109              BNE      |L22.324|
;;;189      {      
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
000130  2101              MOVS     r1,#1
000132  2040              MOVS     r0,#0x40
000134  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
000138  2100              MOVS     r1,#0
00013a  e8bd4010          POP      {r4,lr}
00013e  2040              MOVS     r0,#0x40
000140  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.324|
;;;192      }  
;;;193      else if (TIMx == TIM13) 
000144  492d              LDR      r1,|L22.508|
000146  4288              CMP      r0,r1
000148  d109              BNE      |L22.350|
;;;194      {       
;;;195        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
00014a  2101              MOVS     r1,#1
00014c  2080              MOVS     r0,#0x80
00014e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;196        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
000152  2100              MOVS     r1,#0
000154  e8bd4010          POP      {r4,lr}
000158  2080              MOVS     r0,#0x80
00015a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.350|
;;;197      }
;;;198      else if (TIMx == TIM14) 
00015e  4928              LDR      r1,|L22.512|
000160  4288              CMP      r0,r1
000162  d10a              BNE      |L22.378|
;;;199      {       
;;;200        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000164  1584              ASRS     r4,r0,#22
000166  2101              MOVS     r1,#1
000168  4620              MOV      r0,r4
00016a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;201        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
00016e  4620              MOV      r0,r4
000170  e8bd4010          POP      {r4,lr}
000174  2100              MOVS     r1,#0
000176  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L22.378|
;;;202      }        
;;;203      else if (TIMx == TIM15)
00017a  4922              LDR      r1,|L22.516|
00017c  4288              CMP      r0,r1
00017e  d10a              BNE      |L22.406|
;;;204      {
;;;205        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
000180  2101              MOVS     r1,#1
000182  040c              LSLS     r4,r1,#16
000184  4620              MOV      r0,r4
000186  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;206        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
00018a  4620              MOV      r0,r4
00018c  e8bd4010          POP      {r4,lr}
000190  2100              MOVS     r1,#0
000192  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.406|
;;;207      } 
;;;208      else if (TIMx == TIM16)
000196  491c              LDR      r1,|L22.520|
000198  4288              CMP      r0,r1
00019a  d10a              BNE      |L22.434|
;;;209      {
;;;210        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
00019c  2101              MOVS     r1,#1
00019e  044c              LSLS     r4,r1,#17
0001a0  4620              MOV      r0,r4
0001a2  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;211        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
0001a6  4620              MOV      r0,r4
0001a8  e8bd4010          POP      {r4,lr}
0001ac  2100              MOVS     r1,#0
0001ae  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.434|
;;;212      } 
;;;213      else
;;;214      {
;;;215        if (TIMx == TIM17)
0001b2  4916              LDR      r1,|L22.524|
0001b4  4288              CMP      r0,r1
0001b6  d10a              BNE      |L22.462|
;;;216        {
;;;217          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
0001b8  2101              MOVS     r1,#1
0001ba  048c              LSLS     r4,r1,#18
0001bc  4620              MOV      r0,r4
0001be  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;218          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
0001c2  4620              MOV      r0,r4
0001c4  e8bd4010          POP      {r4,lr}
0001c8  2100              MOVS     r1,#0
0001ca  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L22.462|
;;;219        }  
;;;220      }
;;;221    }
0001ce  bd10              POP      {r4,pc}
;;;222    
                          ENDP

                  |L22.464|
                          DCD      0x40012c00
                  |L22.468|
                          DCD      0x40000400
                  |L22.472|
                          DCD      0x40000800
                  |L22.476|
                          DCD      0x40000c00
                  |L22.480|
                          DCD      0x40001000
                  |L22.484|
                          DCD      0x40001400
                  |L22.488|
                          DCD      0x40013400
                  |L22.492|
                          DCD      0x40014c00
                  |L22.496|
                          DCD      0x40015000
                  |L22.500|
                          DCD      0x40015400
                  |L22.504|
                          DCD      0x40001800
                  |L22.508|
                          DCD      0x40001c00
                  |L22.512|
                          DCD      0x40002000
                  |L22.516|
                          DCD      0x40014000
                  |L22.520|
                          DCD      0x40014400
                  |L22.524|
                          DCD      0x40014800

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1080     */
;;;1081   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b510              PUSH     {r4,lr}
;;;1082                                uint16_t ExtTRGFilter)
;;;1083   {
000002  4604              MOV      r4,r0
;;;1084     uint16_t tmpsmcr = 0;
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1087     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1088     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1089     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1090     /* Configure the ETR Clock source */
;;;1091     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       TIM_ETRConfig
;;;1092     
;;;1093     /* Get the TIMx SMCR register value */
;;;1094     tmpsmcr = TIMx->SMCR;
00000a  8920              LDRH     r0,[r4,#8]
;;;1095     /* Reset the SMS Bits */
;;;1096     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
00000c  f0200007          BIC      r0,r0,#7
;;;1097     /* Select the External clock mode1 */
;;;1098     tmpsmcr |= TIM_SlaveMode_External1;
000010  f0400007          ORR      r0,r0,#7
;;;1099     /* Select the Trigger selection : ETRF */
;;;1100     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000014  f0200070          BIC      r0,r0,#0x70
;;;1101     tmpsmcr |= TIM_TS_ETRF;
000018  f0400070          ORR      r0,r0,#0x70
;;;1102     /* Write to TIMx SMCR */
;;;1103     TIMx->SMCR = tmpsmcr;
00001c  8120              STRH     r0,[r4,#8]
;;;1104   }
00001e  bd10              POP      {r4,pc}
;;;1105   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1122     */
;;;1123   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b510              PUSH     {r4,lr}
;;;1124                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1125   {
000002  4604              MOV      r4,r0
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1128     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1129     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1130     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1131     /* Configure the ETR Clock source */
;;;1132     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       TIM_ETRConfig
;;;1133     /* Enable the External clock mode2 */
;;;1134     TIMx->SMCR |= TIM_SMCR_ECE;
00000a  8920              LDRH     r0,[r4,#8]
00000c  f4404080          ORR      r0,r0,#0x4000
000010  8120              STRH     r0,[r4,#8]
;;;1135   }
000012  bd10              POP      {r4,pc}
;;;1136   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1153     */
;;;1154   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b530              PUSH     {r4,r5,lr}
;;;1155                      uint16_t ExtTRGFilter)
;;;1156   {
;;;1157     uint16_t tmpsmcr = 0;
;;;1158     /* Check the parameters */
;;;1159     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1160     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1161     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1162     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1163     tmpsmcr = TIMx->SMCR;
000002  8904              LDRH     r4,[r0,#8]
;;;1164     /* Reset the ETR Bits */
;;;1165     tmpsmcr &= SMCR_ETR_Mask;
000004  b2e4              UXTB     r4,r4
;;;1166     /* Set the Prescaler, the Filter value and the Polarity */
;;;1167     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000006  f64f75ff          MOV      r5,#0xffff
00000a  ea052303          AND      r3,r5,r3,LSL #8
00000e  4313              ORRS     r3,r3,r2
000010  430b              ORRS     r3,r3,r1
000012  4323              ORRS     r3,r3,r4
;;;1168     /* Write to TIMx SMCR */
;;;1169     TIMx->SMCR = tmpsmcr;
000014  8103              STRH     r3,[r0,#8]
;;;1170   }
000016  bd30              POP      {r4,r5,pc}
;;;1171   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1269     */
;;;1270   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b570              PUSH     {r4-r6,lr}
;;;1271                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1272   {
;;;1273     uint16_t tmpsmcr = 0;
;;;1274     uint16_t tmpccmr1 = 0;
;;;1275     uint16_t tmpccer = 0;
;;;1276       
;;;1277     /* Check the parameters */
;;;1278     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1279     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1280     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1281     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1282   
;;;1283     /* Get the TIMx SMCR register value */
;;;1284     tmpsmcr = TIMx->SMCR;
000002  8905              LDRH     r5,[r0,#8]
;;;1285     
;;;1286     /* Get the TIMx CCMR1 register value */
;;;1287     tmpccmr1 = TIMx->CCMR1;
000004  8b04              LDRH     r4,[r0,#0x18]
;;;1288     
;;;1289     /* Get the TIMx CCER register value */
;;;1290     tmpccer = TIMx->CCER;
000006  8c06              LDRH     r6,[r0,#0x20]
;;;1291     
;;;1292     /* Set the encoder Mode */
;;;1293     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000008  f0250507          BIC      r5,r5,#7
;;;1294     tmpsmcr |= TIM_EncoderMode;
00000c  430d              ORRS     r5,r5,r1
;;;1295     
;;;1296     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1297     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
00000e  f64f41fc          MOV      r1,#0xfcfc
000012  400c              ANDS     r4,r4,r1
;;;1298     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000014  f2401101          MOV      r1,#0x101
000018  430c              ORRS     r4,r4,r1
;;;1299     
;;;1300     /* Set the TI1 and the TI2 Polarities */
;;;1301     tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
00001a  f0260622          BIC      r6,r6,#0x22
;;;1302     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00001e  f64f71ff          MOV      r1,#0xffff
000022  ea011103          AND      r1,r1,r3,LSL #4
000026  4311              ORRS     r1,r1,r2
000028  4331              ORRS     r1,r1,r6
;;;1303     
;;;1304     /* Write to TIMx SMCR */
;;;1305     TIMx->SMCR = tmpsmcr;
00002a  8105              STRH     r5,[r0,#8]
;;;1306     /* Write to TIMx CCMR1 */
;;;1307     TIMx->CCMR1 = tmpccmr1;
00002c  8304              STRH     r4,[r0,#0x18]
;;;1308     /* Write to TIMx CCER */
;;;1309     TIMx->CCER = tmpccer;
00002e  8401              STRH     r1,[r0,#0x20]
;;;1310   }
000030  bd70              POP      {r4-r6,pc}
;;;1311   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1320     */
;;;1321   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1322   {
;;;1323     uint16_t tmpccmr1 = 0;
;;;1324     /* Check the parameters */
;;;1325     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1326     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1327     tmpccmr1 = TIMx->CCMR1;
;;;1328     /* Reset the OC1M Bits */
;;;1329     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000002  f0220270          BIC      r2,r2,#0x70
;;;1330     /* Configure The Forced output Mode */
;;;1331     tmpccmr1 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1332     /* Write to TIMx CCMR1 register */
;;;1333     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1334   }
00000a  4770              BX       lr
;;;1335   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1344     */
;;;1345   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1346   {
;;;1347     uint16_t tmpccmr1 = 0;
;;;1348     /* Check the parameters */
;;;1349     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1350     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1351     tmpccmr1 = TIMx->CCMR1;
;;;1352     /* Reset the OC2M Bits */
;;;1353     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1354     /* Configure The Forced output Mode */
;;;1355     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1356     /* Write to TIMx CCMR1 register */
;;;1357     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1358   }
000012  4770              BX       lr
;;;1359   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1368     */
;;;1369   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1370   {
;;;1371     uint16_t tmpccmr2 = 0;
;;;1372     /* Check the parameters */
;;;1373     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1374     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1375     tmpccmr2 = TIMx->CCMR2;
;;;1376     /* Reset the OC1M Bits */
;;;1377     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000002  f0220270          BIC      r2,r2,#0x70
;;;1378     /* Configure The Forced output Mode */
;;;1379     tmpccmr2 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1380     /* Write to TIMx CCMR2 register */
;;;1381     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1382   }
00000a  4770              BX       lr
;;;1383   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1392     */
;;;1393   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1394   {
;;;1395     uint16_t tmpccmr2 = 0;
;;;1396     /* Check the parameters */
;;;1397     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1398     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1399     tmpccmr2 = TIMx->CCMR2;
;;;1400     /* Reset the OC2M Bits */
;;;1401     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1402     /* Configure The Forced output Mode */
;;;1403     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1404     /* Write to TIMx CCMR2 register */
;;;1405     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1406   }
000012  4770              BX       lr
;;;1407   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;914      */
;;;915    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;916    { 
;;;917      /* Check the parameters */
;;;918      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;919      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;920      
;;;921      /* Set the event sources */
;;;922      TIMx->EGR = TIM_EventSource;
;;;923    }
000002  4770              BX       lr
;;;924    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2462     */
;;;2463   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  8e80              LDRH     r0,[r0,#0x34]
;;;2464   {
;;;2465     /* Check the parameters */
;;;2466     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2467     /* Get the Capture 1 Register value */
;;;2468     return TIMx->CCR1;
;;;2469   }
000002  4770              BX       lr
;;;2470   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2475     */
;;;2476   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  8f00              LDRH     r0,[r0,#0x38]
;;;2477   {
;;;2478     /* Check the parameters */
;;;2479     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2480     /* Get the Capture 2 Register value */
;;;2481     return TIMx->CCR2;
;;;2482   }
000002  4770              BX       lr
;;;2483   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2488     */
;;;2489   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  8f80              LDRH     r0,[r0,#0x3c]
;;;2490   {
;;;2491     /* Check the parameters */
;;;2492     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2493     /* Get the Capture 3 Register value */
;;;2494     return TIMx->CCR3;
;;;2495   }
000002  4770              BX       lr
;;;2496   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2501     */
;;;2502   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  f8b00040          LDRH     r0,[r0,#0x40]
;;;2503   {
;;;2504     /* Check the parameters */
;;;2505     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2506     /* Get the Capture 4 Register value */
;;;2507     return TIMx->CCR4;
;;;2508   }
000004  4770              BX       lr
;;;2509   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2514     */
;;;2515   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  8c80              LDRH     r0,[r0,#0x24]
;;;2516   {
;;;2517     /* Check the parameters */
;;;2518     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2519     /* Get the Counter Register value */
;;;2520     return TIMx->CNT;
;;;2521   }
000002  4770              BX       lr
;;;2522   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2561     */
;;;2562   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2563   { 
;;;2564     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2565     /* Check the parameters */
;;;2566     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2567     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2568     
;;;2569     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L37.12|
;;;2570     {
;;;2571       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L37.12|
;;;2572     }
;;;2573     else
;;;2574     {
;;;2575       bitstatus = RESET;
;;;2576     }
;;;2577     return bitstatus;
;;;2578   }
00000c  4770              BX       lr
;;;2579   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2637     */
;;;2638   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  4602              MOV      r2,r0
;;;2639   {
;;;2640     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2641     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2642     /* Check the parameters */
;;;2643     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2644     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2645      
;;;2646     itstatus = TIMx->SR & TIM_IT;
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
;;;2647     
;;;2648     itenable = TIMx->DIER & TIM_IT;
000008  8992              LDRH     r2,[r2,#0xc]
00000a  400a              ANDS     r2,r2,r1
;;;2649     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
00000c  2b00              CMP      r3,#0
00000e  d002              BEQ      |L38.22|
000010  2a00              CMP      r2,#0
000012  d000              BEQ      |L38.22|
;;;2650     {
;;;2651       bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L38.22|
;;;2652     }
;;;2653     else
;;;2654     {
;;;2655       bitstatus = RESET;
;;;2656     }
;;;2657     return bitstatus;
;;;2658   }
000016  4770              BX       lr
;;;2659   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2527     */
;;;2528   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;2529   {
;;;2530     /* Check the parameters */
;;;2531     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2532     /* Get the Prescaler Register value */
;;;2533     return TIMx->PSC;
;;;2534   }
000002  4770              BX       lr
;;;2535   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=2

                  TIM_ICInit PROC
;;;592      */
;;;593    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;594    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;595      /* Check the parameters */
;;;596      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
;;;597      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;598      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;599      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;600      
;;;601      if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000006  481d              LDR      r0,|L40.124|
000008  4285              CMP      r5,r0
00000a  d009              BEQ      |L40.32|
00000c  481c              LDR      r0,|L40.128|
00000e  4285              CMP      r5,r0
000010  d006              BEQ      |L40.32|
000012  f1b54f80          CMP      r5,#0x40000000
000016  d003              BEQ      |L40.32|
000018  481a              LDR      r0,|L40.132|
00001a  4285              CMP      r5,r0
00001c  d000              BEQ      |L40.32|
;;;602         (TIMx == TIM4) ||(TIMx == TIM5))
00001e  481a              LDR      r0,|L40.136|
                  |L40.32|
;;;603      {
;;;604        assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;605      }
;;;606      else
;;;607      {
;;;608        assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
;;;609      }
;;;610      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000020  8820              LDRH     r0,[r4,#0]
;;;611      {
;;;612        assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;613        /* TI1 Configuration */
;;;614        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000022  8861              LDRH     r1,[r4,#2]
000024  88a2              LDRH     r2,[r4,#4]
000026  8923              LDRH     r3,[r4,#8]
000028  b160              CBZ      r0,|L40.68|
;;;615                   TIM_ICInitStruct->TIM_ICSelection,
;;;616                   TIM_ICInitStruct->TIM_ICFilter);
;;;617        /* Set the Input Capture Prescaler value */
;;;618        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;619      }
;;;620      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
00002a  2804              CMP      r0,#4
00002c  d013              BEQ      |L40.86|
;;;621      {
;;;622        assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;623        /* TI2 Configuration */
;;;624        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;625                   TIM_ICInitStruct->TIM_ICSelection,
;;;626                   TIM_ICInitStruct->TIM_ICFilter);
;;;627        /* Set the Input Capture Prescaler value */
;;;628        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;629      }
;;;630      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00002e  2808              CMP      r0,#8
000030  d01a              BEQ      |L40.104|
;;;631      {
;;;632        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;633        /* TI3 Configuration */
;;;634        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;635                   TIM_ICInitStruct->TIM_ICSelection,
;;;636                   TIM_ICInitStruct->TIM_ICFilter);
;;;637        /* Set the Input Capture Prescaler value */
;;;638        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;639      }
;;;640      else
;;;641      {
;;;642        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;643        /* TI4 Configuration */
;;;644        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       TI4_Config
;;;645                   TIM_ICInitStruct->TIM_ICSelection,
;;;646                   TIM_ICInitStruct->TIM_ICFilter);
;;;647        /* Set the Input Capture Prescaler value */
;;;648        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000038  88e1              LDRH     r1,[r4,#6]
00003a  4628              MOV      r0,r5
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      TIM_SetIC4Prescaler
                  |L40.68|
000044  4628              MOV      r0,r5                 ;614
000046  f7fffffe          BL       TI1_Config
00004a  88e1              LDRH     r1,[r4,#6]            ;618
00004c  4628              MOV      r0,r5                 ;618
00004e  e8bd4070          POP      {r4-r6,lr}            ;618
000052  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L40.86|
000056  4628              MOV      r0,r5                 ;624
000058  f7fffffe          BL       TI2_Config
00005c  88e1              LDRH     r1,[r4,#6]            ;628
00005e  4628              MOV      r0,r5                 ;628
000060  e8bd4070          POP      {r4-r6,lr}            ;628
000064  f7ffbffe          B.W      TIM_SetIC2Prescaler
                  |L40.104|
000068  4628              MOV      r0,r5                 ;634
00006a  f7fffffe          BL       TI3_Config
00006e  88e1              LDRH     r1,[r4,#6]            ;638
000070  4628              MOV      r0,r5                 ;638
000072  e8bd4070          POP      {r4-r6,lr}            ;638
000076  f7ffbffe          B.W      TIM_SetIC3Prescaler
;;;649      }
;;;650    }
;;;651    
                          ENDP

00007a  0000              DCW      0x0000
                  |L40.124|
                          DCD      0x40012c00
                  |L40.128|
                          DCD      0x40013400
                  |L40.132|
                          DCD      0x40000400
                  |L40.136|
                          DCD      0x40000800

                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;776      */
;;;777    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;778    {
;;;779      /* Set the default configuration */
;;;780      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;781      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;782      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;783      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;784      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;785    }
00000e  4770              BX       lr
;;;786    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;877      */
;;;878    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;879    {  
000002  d003              BEQ      |L42.12|
;;;880      /* Check the parameters */
;;;881      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;882      assert_param(IS_TIM_IT(TIM_IT));
;;;883      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;884      
;;;885      if (NewState != DISABLE)
;;;886      {
;;;887        /* Enable the Interrupt sources */
;;;888        TIMx->DIER |= TIM_IT;
000004  8982              LDRH     r2,[r0,#0xc]
000006  430a              ORRS     r2,r2,r1
000008  8182              STRH     r2,[r0,#0xc]
;;;889      }
;;;890      else
;;;891      {
;;;892        /* Disable the Interrupt sources */
;;;893        TIMx->DIER &= (uint16_t)~TIM_IT;
;;;894      }
;;;895    }
00000a  4770              BX       lr
                  |L42.12|
00000c  8982              LDRH     r2,[r0,#0xc]          ;893
00000e  438a              BICS     r2,r2,r1              ;893
000010  8182              STRH     r2,[r0,#0xc]          ;893
000012  4770              BX       lr
;;;896    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;1013     */
;;;1014   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b500              PUSH     {lr}
;;;1015   {
000002  4603              MOV      r3,r0
;;;1016     /* Check the parameters */
;;;1017     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1018     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1019     /* Select the Internal Trigger */
;;;1020     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       TIM_SelectInputTrigger
;;;1021     /* Select the External clock mode1 */
;;;1022     TIMx->SMCR |= TIM_SlaveMode_External1;
00000a  8918              LDRH     r0,[r3,#8]
00000c  f0400007          ORR      r0,r0,#7
000010  8118              STRH     r0,[r3,#8]
;;;1023   }
000012  bd00              POP      {pc}
;;;1024   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;994      */
;;;995    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;996    {
;;;997      /* Check the parameters */
;;;998      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;999      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;1000     TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000002  f0210107          BIC      r1,r1,#7
000006  8101              STRH     r1,[r0,#8]
;;;1001   }
000008  4770              BX       lr
;;;1002   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1611     */
;;;1612   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1613   {
;;;1614     uint16_t tmpccmr1 = 0;
;;;1615     /* Check the parameters */
;;;1616     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1617     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1618     /* Get the TIMx CCMR1 register value */
;;;1619     tmpccmr1 = TIMx->CCMR1;
;;;1620     /* Reset the OC1FE Bit */
;;;1621     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000002  f0220204          BIC      r2,r2,#4
;;;1622     /* Enable or Disable the Output Compare Fast Bit */
;;;1623     tmpccmr1 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1624     /* Write to TIMx CCMR1 */
;;;1625     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1626   }
00000a  4770              BX       lr
;;;1627   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;284      */
;;;285    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;286    {
;;;287      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;288       
;;;289      /* Check the parameters */
;;;290      assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;291      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;292      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;293      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;294     /* Disable the Channel 1: Reset the CC1E Bit */
;;;295      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  8402              STRH     r2,[r0,#0x20]
;;;296      /* Get the TIMx CCER register value */
;;;297      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;298      /* Get the TIMx CR2 register value */
;;;299      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;300      
;;;301      /* Get the TIMx CCMR1 register value */
;;;302      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;303        
;;;304      /* Reset the Output Compare Mode Bits */
;;;305      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
000010  f0240470          BIC      r4,r4,#0x70
;;;306      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
000014  f0240503          BIC      r5,r4,#3
;;;307    
;;;308      /* Select the Output Compare Mode */
;;;309      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000018  880c              LDRH     r4,[r1,#0]
00001a  432c              ORRS     r4,r4,r5
;;;310      
;;;311      /* Reset the Output Polarity level */
;;;312      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
00001c  f0220202          BIC      r2,r2,#2
;;;313      /* Set the Output Compare Polarity */
;;;314      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000020  890d              LDRH     r5,[r1,#8]
000022  4315              ORRS     r5,r5,r2
;;;315      
;;;316      /* Set the Output State */
;;;317      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000024  884a              LDRH     r2,[r1,#2]
000026  432a              ORRS     r2,r2,r5
;;;318        
;;;319      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
000028  4d12              LDR      r5,|L46.116|
00002a  42a8              CMP      r0,r5
00002c  d00b              BEQ      |L46.70|
00002e  4d12              LDR      r5,|L46.120|
000030  42a8              CMP      r0,r5
000032  d008              BEQ      |L46.70|
000034  4d11              LDR      r5,|L46.124|
000036  42a8              CMP      r0,r5
000038  d005              BEQ      |L46.70|
;;;320         (TIMx == TIM16)|| (TIMx == TIM17))
00003a  4d11              LDR      r5,|L46.128|
00003c  42a8              CMP      r0,r5
00003e  d002              BEQ      |L46.70|
000040  4d10              LDR      r5,|L46.132|
000042  42a8              CMP      r0,r5
000044  d10f              BNE      |L46.102|
                  |L46.70|
;;;321      {
;;;322        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;323        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;324        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;325        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;326        
;;;327        /* Reset the Output N Polarity level */
;;;328        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
000046  f0220508          BIC      r5,r2,#8
;;;329        /* Set the Output N Polarity */
;;;330        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00004a  894a              LDRH     r2,[r1,#0xa]
00004c  432a              ORRS     r2,r2,r5
;;;331        
;;;332        /* Reset the Output N State */
;;;333        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
00004e  f0220504          BIC      r5,r2,#4
;;;334        /* Set the Output N State */
;;;335        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000052  888a              LDRH     r2,[r1,#4]
000054  432a              ORRS     r2,r2,r5
;;;336        
;;;337        /* Reset the Output Compare and Output Compare N IDLE State */
;;;338        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
000056  f4237380          BIC      r3,r3,#0x100
;;;339        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
00005a  f4237300          BIC      r3,r3,#0x200
;;;340        
;;;341        /* Set the Output Idle state */
;;;342        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005e  898d              LDRH     r5,[r1,#0xc]
000060  431d              ORRS     r5,r5,r3
;;;343        /* Set the Output N Idle state */
;;;344        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000062  89cb              LDRH     r3,[r1,#0xe]
000064  432b              ORRS     r3,r3,r5
                  |L46.102|
;;;345      }
;;;346      /* Write to TIMx CR2 */
;;;347      TIMx->CR2 = tmpcr2;
000066  8083              STRH     r3,[r0,#4]
;;;348      
;;;349      /* Write to TIMx CCMR1 */
;;;350      TIMx->CCMR1 = tmpccmrx;
000068  8304              STRH     r4,[r0,#0x18]
;;;351    
;;;352      /* Set the Capture Compare Register value */
;;;353      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
00006a  88c9              LDRH     r1,[r1,#6]
00006c  8681              STRH     r1,[r0,#0x34]
;;;354     
;;;355      /* Write to TIMx CCER */
;;;356      TIMx->CCER = tmpccer;
00006e  8402              STRH     r2,[r0,#0x20]
;;;357    }
000070  bd30              POP      {r4,r5,pc}
;;;358    
                          ENDP

000072  0000              DCW      0x0000
                  |L46.116|
                          DCD      0x40012c00
                  |L46.120|
                          DCD      0x40013400
                  |L46.124|
                          DCD      0x40014000
                  |L46.128|
                          DCD      0x40014400
                  |L46.132|
                          DCD      0x40014800

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1833     */
;;;1834   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1835   {
;;;1836     uint16_t tmpccer = 0;
;;;1837     /* Check the parameters */
;;;1838     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1839     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1840      
;;;1841     tmpccer = TIMx->CCER;
;;;1842     /* Set or Reset the CC1NP Bit */
;;;1843     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000002  f0220208          BIC      r2,r2,#8
;;;1844     tmpccer |= TIM_OCNPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1845     /* Write to TIMx CCER register */
;;;1846     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1847   }
00000a  4770              BX       lr
;;;1848   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1810     */
;;;1811   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1812   {
;;;1813     uint16_t tmpccer = 0;
;;;1814     /* Check the parameters */
;;;1815     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1816     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1817     tmpccer = TIMx->CCER;
;;;1818     /* Set or Reset the CC1P Bit */
;;;1819     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;1820     tmpccer |= TIM_OCPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1821     /* Write to TIMx CCER register */
;;;1822     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1823   }
00000a  4770              BX       lr
;;;1824   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1514     */
;;;1515   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1516   {
;;;1517     uint16_t tmpccmr1 = 0;
;;;1518     /* Check the parameters */
;;;1519     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1520     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1521     tmpccmr1 = TIMx->CCMR1;
;;;1522     /* Reset the OC1PE Bit */
;;;1523     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1524     /* Enable or Disable the Output Compare Preload feature */
;;;1525     tmpccmr1 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1526     /* Write to TIMx CCMR1 register */
;;;1527     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1528   }
00000a  4770              BX       lr
;;;1529   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1637     */
;;;1638   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1639   {
;;;1640     uint16_t tmpccmr1 = 0;
;;;1641     /* Check the parameters */
;;;1642     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1643     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1644     /* Get the TIMx CCMR1 register value */
;;;1645     tmpccmr1 = TIMx->CCMR1;
;;;1646     /* Reset the OC2FE Bit */
;;;1647     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1648     /* Enable or Disable the Output Compare Fast Bit */
;;;1649     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1650     /* Write to TIMx CCMR1 */
;;;1651     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1652   }
000012  4770              BX       lr
;;;1653   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;367      */
;;;368    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
;;;370      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;371       
;;;372      /* Check the parameters */
;;;373      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;374      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;375      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;376      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;377       /* Disable the Channel 2: Reset the CC2E Bit */
;;;378      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  8402              STRH     r2,[r0,#0x20]
;;;379      
;;;380      /* Get the TIMx CCER register value */  
;;;381      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;382      /* Get the TIMx CR2 register value */
;;;383      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;384      
;;;385      /* Get the TIMx CCMR1 register value */
;;;386      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;387        
;;;388      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;389      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
000010  f42444e0          BIC      r4,r4,#0x7000
;;;390      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
000014  f4247640          BIC      r6,r4,#0x300
;;;391      
;;;392      /* Select the Output Compare Mode */
;;;393      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000018  880d              LDRH     r5,[r1,#0]
00001a  f64f74ff          MOV      r4,#0xffff
00001e  ea042505          AND      r5,r4,r5,LSL #8
000022  4335              ORRS     r5,r5,r6
;;;394      
;;;395      /* Reset the Output Polarity level */
;;;396      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
000024  f0220220          BIC      r2,r2,#0x20
;;;397      /* Set the Output Compare Polarity */
;;;398      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000028  890e              LDRH     r6,[r1,#8]
00002a  ea041606          AND      r6,r4,r6,LSL #4
00002e  4316              ORRS     r6,r6,r2
;;;399      
;;;400      /* Set the Output State */
;;;401      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000030  884a              LDRH     r2,[r1,#2]
000032  ea041202          AND      r2,r4,r2,LSL #4
000036  4332              ORRS     r2,r2,r6
;;;402        
;;;403      if((TIMx == TIM1) || (TIMx == TIM8))
000038  4e11              LDR      r6,|L51.128|
00003a  42b0              CMP      r0,r6
00003c  d002              BEQ      |L51.68|
00003e  4e11              LDR      r6,|L51.132|
000040  42b0              CMP      r0,r6
000042  d117              BNE      |L51.116|
                  |L51.68|
;;;404      {
;;;405        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;406        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;407        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;408        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;409        
;;;410        /* Reset the Output N Polarity level */
;;;411        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
000044  f0220280          BIC      r2,r2,#0x80
;;;412        /* Set the Output N Polarity */
;;;413        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000048  894e              LDRH     r6,[r1,#0xa]
00004a  ea041606          AND      r6,r4,r6,LSL #4
00004e  4316              ORRS     r6,r6,r2
;;;414        
;;;415        /* Reset the Output N State */
;;;416        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
000050  f0260640          BIC      r6,r6,#0x40
;;;417        /* Set the Output N State */
;;;418        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000054  888a              LDRH     r2,[r1,#4]
000056  ea041202          AND      r2,r4,r2,LSL #4
00005a  4332              ORRS     r2,r2,r6
;;;419        
;;;420        /* Reset the Output Compare and Output Compare N IDLE State */
;;;421        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
00005c  f4236380          BIC      r3,r3,#0x400
;;;422        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
000060  f4236300          BIC      r3,r3,#0x800
;;;423        
;;;424        /* Set the Output Idle state */
;;;425        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000064  898e              LDRH     r6,[r1,#0xc]
000066  ea040686          AND      r6,r4,r6,LSL #2
00006a  431e              ORRS     r6,r6,r3
;;;426        /* Set the Output N Idle state */
;;;427        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
00006c  89cb              LDRH     r3,[r1,#0xe]
00006e  ea040383          AND      r3,r4,r3,LSL #2
000072  4333              ORRS     r3,r3,r6
                  |L51.116|
;;;428      }
;;;429      /* Write to TIMx CR2 */
;;;430      TIMx->CR2 = tmpcr2;
000074  8083              STRH     r3,[r0,#4]
;;;431      
;;;432      /* Write to TIMx CCMR1 */
;;;433      TIMx->CCMR1 = tmpccmrx;
000076  8305              STRH     r5,[r0,#0x18]
;;;434    
;;;435      /* Set the Capture Compare Register value */
;;;436      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000078  88c9              LDRH     r1,[r1,#6]
00007a  8701              STRH     r1,[r0,#0x38]
;;;437      
;;;438      /* Write to TIMx CCER */
;;;439      TIMx->CCER = tmpccer;
00007c  8402              STRH     r2,[r0,#0x20]
;;;440    }
00007e  bd70              POP      {r4-r6,pc}
;;;441    
                          ENDP

                  |L51.128|
                          DCD      0x40012c00
                  |L51.132|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1880     */
;;;1881   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1882   {
;;;1883     uint16_t tmpccer = 0;
;;;1884     /* Check the parameters */
;;;1885     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1886     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1887     
;;;1888     tmpccer = TIMx->CCER;
;;;1889     /* Set or Reset the CC2NP Bit */
;;;1890     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
000002  f0220280          BIC      r2,r2,#0x80
;;;1891     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1892     /* Write to TIMx CCER register */
;;;1893     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1894   }
000012  4770              BX       lr
;;;1895   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1857     */
;;;1858   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1859   {
;;;1860     uint16_t tmpccer = 0;
;;;1861     /* Check the parameters */
;;;1862     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1863     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1864     tmpccer = TIMx->CCER;
;;;1865     /* Set or Reset the CC2P Bit */
;;;1866     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
000002  f0220220          BIC      r2,r2,#0x20
;;;1867     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1868     /* Write to TIMx CCER register */
;;;1869     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1870   }
000012  4770              BX       lr
;;;1871   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1539     */
;;;1540   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1541   {
;;;1542     uint16_t tmpccmr1 = 0;
;;;1543     /* Check the parameters */
;;;1544     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1545     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1546     tmpccmr1 = TIMx->CCMR1;
;;;1547     /* Reset the OC2PE Bit */
;;;1548     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1549     /* Enable or Disable the Output Compare Preload feature */
;;;1550     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1551     /* Write to TIMx CCMR1 register */
;;;1552     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1553   }
000012  4770              BX       lr
;;;1554   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1662     */
;;;1663   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1664   {
;;;1665     uint16_t tmpccmr2 = 0;
;;;1666     /* Check the parameters */
;;;1667     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1668     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1669     /* Get the TIMx CCMR2 register value */
;;;1670     tmpccmr2 = TIMx->CCMR2;
;;;1671     /* Reset the OC3FE Bit */
;;;1672     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000002  f0220204          BIC      r2,r2,#4
;;;1673     /* Enable or Disable the Output Compare Fast Bit */
;;;1674     tmpccmr2 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1675     /* Write to TIMx CCMR2 */
;;;1676     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1677   }
00000a  4770              BX       lr
;;;1678   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;449      */
;;;450    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;451    {
;;;452      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;453       
;;;454      /* Check the parameters */
;;;455      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;456      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;457      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;458      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;459      /* Disable the Channel 2: Reset the CC2E Bit */
;;;460      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  8402              STRH     r2,[r0,#0x20]
;;;461      
;;;462      /* Get the TIMx CCER register value */
;;;463      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;464      /* Get the TIMx CR2 register value */
;;;465      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;466      
;;;467      /* Get the TIMx CCMR2 register value */
;;;468      tmpccmrx = TIMx->CCMR2;
00000e  8b84              LDRH     r4,[r0,#0x1c]
;;;469        
;;;470      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;471      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
000010  f0240470          BIC      r4,r4,#0x70
;;;472      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
000014  f0240403          BIC      r4,r4,#3
;;;473      /* Select the Output Compare Mode */
;;;474      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000018  880d              LDRH     r5,[r1,#0]
00001a  4325              ORRS     r5,r5,r4
;;;475      
;;;476      /* Reset the Output Polarity level */
;;;477      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
00001c  f4227200          BIC      r2,r2,#0x200
;;;478      /* Set the Output Compare Polarity */
;;;479      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000020  890e              LDRH     r6,[r1,#8]
000022  f64f74ff          MOV      r4,#0xffff
000026  ea042606          AND      r6,r4,r6,LSL #8
00002a  4316              ORRS     r6,r6,r2
;;;480      
;;;481      /* Set the Output State */
;;;482      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00002c  884a              LDRH     r2,[r1,#2]
00002e  ea042202          AND      r2,r4,r2,LSL #8
000032  4332              ORRS     r2,r2,r6
;;;483        
;;;484      if((TIMx == TIM1) || (TIMx == TIM8))
000034  4e11              LDR      r6,|L56.124|
000036  42b0              CMP      r0,r6
000038  d002              BEQ      |L56.64|
00003a  4e11              LDR      r6,|L56.128|
00003c  42b0              CMP      r0,r6
00003e  d117              BNE      |L56.112|
                  |L56.64|
;;;485      {
;;;486        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;487        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;488        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;489        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;490        
;;;491        /* Reset the Output N Polarity level */
;;;492        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
000040  f4226600          BIC      r6,r2,#0x800
;;;493        /* Set the Output N Polarity */
;;;494        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000044  894a              LDRH     r2,[r1,#0xa]
000046  ea042202          AND      r2,r4,r2,LSL #8
00004a  4332              ORRS     r2,r2,r6
;;;495        /* Reset the Output N State */
;;;496        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
00004c  f4226680          BIC      r6,r2,#0x400
;;;497        
;;;498        /* Set the Output N State */
;;;499        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000050  888a              LDRH     r2,[r1,#4]
000052  ea042202          AND      r2,r4,r2,LSL #8
000056  4332              ORRS     r2,r2,r6
;;;500        /* Reset the Output Compare and Output Compare N IDLE State */
;;;501        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
000058  f4235380          BIC      r3,r3,#0x1000
;;;502        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
00005c  f4235300          BIC      r3,r3,#0x2000
;;;503        /* Set the Output Idle state */
;;;504        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000060  898e              LDRH     r6,[r1,#0xc]
000062  ea041606          AND      r6,r4,r6,LSL #4
000066  431e              ORRS     r6,r6,r3
;;;505        /* Set the Output N Idle state */
;;;506        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000068  89cb              LDRH     r3,[r1,#0xe]
00006a  ea041303          AND      r3,r4,r3,LSL #4
00006e  4333              ORRS     r3,r3,r6
                  |L56.112|
;;;507      }
;;;508      /* Write to TIMx CR2 */
;;;509      TIMx->CR2 = tmpcr2;
000070  8083              STRH     r3,[r0,#4]
;;;510      
;;;511      /* Write to TIMx CCMR2 */
;;;512      TIMx->CCMR2 = tmpccmrx;
000072  8385              STRH     r5,[r0,#0x1c]
;;;513    
;;;514      /* Set the Capture Compare Register value */
;;;515      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000074  88c9              LDRH     r1,[r1,#6]
000076  8781              STRH     r1,[r0,#0x3c]
;;;516      
;;;517      /* Write to TIMx CCER */
;;;518      TIMx->CCER = tmpccer;
000078  8402              STRH     r2,[r0,#0x20]
;;;519    }
00007a  bd70              POP      {r4-r6,pc}
;;;520    
                          ENDP

                  |L56.124|
                          DCD      0x40012c00
                  |L56.128|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1927     */
;;;1928   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1929   {
;;;1930     uint16_t tmpccer = 0;
;;;1931    
;;;1932     /* Check the parameters */
;;;1933     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1934     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1935       
;;;1936     tmpccer = TIMx->CCER;
;;;1937     /* Set or Reset the CC3NP Bit */
;;;1938     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
000002  f4226200          BIC      r2,r2,#0x800
;;;1939     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1940     /* Write to TIMx CCER register */
;;;1941     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1942   }
000012  4770              BX       lr
;;;1943   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1904     */
;;;1905   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1906   {
;;;1907     uint16_t tmpccer = 0;
;;;1908     /* Check the parameters */
;;;1909     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1910     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1911     tmpccer = TIMx->CCER;
;;;1912     /* Set or Reset the CC3P Bit */
;;;1913     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
000002  f4227200          BIC      r2,r2,#0x200
;;;1914     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1915     /* Write to TIMx CCER register */
;;;1916     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1917   }
000012  4770              BX       lr
;;;1918   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1563     */
;;;1564   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1565   {
;;;1566     uint16_t tmpccmr2 = 0;
;;;1567     /* Check the parameters */
;;;1568     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1569     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1570     tmpccmr2 = TIMx->CCMR2;
;;;1571     /* Reset the OC3PE Bit */
;;;1572     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1573     /* Enable or Disable the Output Compare Preload feature */
;;;1574     tmpccmr2 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1575     /* Write to TIMx CCMR2 register */
;;;1576     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1577   }
00000a  4770              BX       lr
;;;1578   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1687     */
;;;1688   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1689   {
;;;1690     uint16_t tmpccmr2 = 0;
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1693     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1694     /* Get the TIMx CCMR2 register value */
;;;1695     tmpccmr2 = TIMx->CCMR2;
;;;1696     /* Reset the OC4FE Bit */
;;;1697     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1698     /* Enable or Disable the Output Compare Fast Bit */
;;;1699     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1700     /* Write to TIMx CCMR2 */
;;;1701     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1702   }
000012  4770              BX       lr
;;;1703   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;528      */
;;;529    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;530    {
;;;531      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;532       
;;;533      /* Check the parameters */
;;;534      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;535      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;536      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;537      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;538      /* Disable the Channel 2: Reset the CC4E Bit */
;;;539      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  8402              STRH     r2,[r0,#0x20]
;;;540      
;;;541      /* Get the TIMx CCER register value */
;;;542      tmpccer = TIMx->CCER;
00000a  8c05              LDRH     r5,[r0,#0x20]
;;;543      /* Get the TIMx CR2 register value */
;;;544      tmpcr2 =  TIMx->CR2;
00000c  8882              LDRH     r2,[r0,#4]
;;;545      
;;;546      /* Get the TIMx CCMR2 register value */
;;;547      tmpccmrx = TIMx->CCMR2;
00000e  8b83              LDRH     r3,[r0,#0x1c]
;;;548        
;;;549      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;550      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
000010  f42343e0          BIC      r3,r3,#0x7000
;;;551      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
000014  f4237640          BIC      r6,r3,#0x300
;;;552      
;;;553      /* Select the Output Compare Mode */
;;;554      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000018  880c              LDRH     r4,[r1,#0]
00001a  f64f73ff          MOV      r3,#0xffff
00001e  ea032404          AND      r4,r3,r4,LSL #8
000022  4334              ORRS     r4,r4,r6
;;;555      
;;;556      /* Reset the Output Polarity level */
;;;557      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
000024  f4255500          BIC      r5,r5,#0x2000
;;;558      /* Set the Output Compare Polarity */
;;;559      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000028  890e              LDRH     r6,[r1,#8]
00002a  ea033606          AND      r6,r3,r6,LSL #12
00002e  432e              ORRS     r6,r6,r5
;;;560      
;;;561      /* Set the Output State */
;;;562      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000030  884d              LDRH     r5,[r1,#2]
000032  ea033505          AND      r5,r3,r5,LSL #12
000036  4335              ORRS     r5,r5,r6
;;;563        
;;;564      if((TIMx == TIM1) || (TIMx == TIM8))
000038  4e09              LDR      r6,|L61.96|
00003a  42b0              CMP      r0,r6
00003c  d002              BEQ      |L61.68|
00003e  4e09              LDR      r6,|L61.100|
000040  42b0              CMP      r0,r6
000042  d105              BNE      |L61.80|
                  |L61.68|
;;;565      {
;;;566        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;567        /* Reset the Output Compare IDLE State */
;;;568        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
000044  f4224680          BIC      r6,r2,#0x4000
;;;569        /* Set the Output Idle state */
;;;570        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000048  898a              LDRH     r2,[r1,#0xc]
00004a  ea031282          AND      r2,r3,r2,LSL #6
00004e  4332              ORRS     r2,r2,r6
                  |L61.80|
;;;571      }
;;;572      /* Write to TIMx CR2 */
;;;573      TIMx->CR2 = tmpcr2;
000050  8082              STRH     r2,[r0,#4]
;;;574      
;;;575      /* Write to TIMx CCMR2 */  
;;;576      TIMx->CCMR2 = tmpccmrx;
000052  8384              STRH     r4,[r0,#0x1c]
;;;577    
;;;578      /* Set the Capture Compare Register value */
;;;579      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000054  88c9              LDRH     r1,[r1,#6]
000056  f8a01040          STRH     r1,[r0,#0x40]
;;;580      
;;;581      /* Write to TIMx CCER */
;;;582      TIMx->CCER = tmpccer;
00005a  8405              STRH     r5,[r0,#0x20]
;;;583    }
00005c  bd70              POP      {r4-r6,pc}
;;;584    
                          ENDP

00005e  0000              DCW      0x0000
                  |L61.96|
                          DCD      0x40012c00
                  |L61.100|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1952     */
;;;1953   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1954   {
;;;1955     uint16_t tmpccer = 0;
;;;1956     /* Check the parameters */
;;;1957     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1958     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1959     tmpccer = TIMx->CCER;
;;;1960     /* Set or Reset the CC4P Bit */
;;;1961     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
000002  f4225200          BIC      r2,r2,#0x2000
;;;1962     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea033101          AND      r1,r3,r1,LSL #12
00000e  4311              ORRS     r1,r1,r2
;;;1963     /* Write to TIMx CCER register */
;;;1964     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1965   }
000012  4770              BX       lr
;;;1966   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1587     */
;;;1588   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1589   {
;;;1590     uint16_t tmpccmr2 = 0;
;;;1591     /* Check the parameters */
;;;1592     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1593     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1594     tmpccmr2 = TIMx->CCMR2;
;;;1595     /* Reset the OC4PE Bit */
;;;1596     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1597     /* Enable or Disable the Output Compare Preload feature */
;;;1598     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000006  f64f73ff          MOV      r3,#0xffff
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1599     /* Write to TIMx CCMR2 register */
;;;1600     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1601   }
000012  4770              BX       lr
;;;1602   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;757      */
;;;758    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;759    {
;;;760      /* Set the default configuration */
;;;761      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;762      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;763      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;764      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;765      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;766      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;767      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;768      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;769    }
000012  4770              BX       lr
;;;770    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;659      */
;;;660    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;661    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;662      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2500              MOVS     r5,#0
;;;663      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2601              MOVS     r6,#1
;;;664      /* Check the parameters */
;;;665      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;666      /* Select the Opposite Input Polarity */
;;;667      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8861              LDRH     r1,[r4,#2]
00000e  2900              CMP      r1,#0
000010  d100              BNE      |L65.20|
;;;668      {
;;;669        icoppositepolarity = TIM_ICPolarity_Falling;
000012  2502              MOVS     r5,#2
                  |L65.20|
;;;670      }
;;;671      else
;;;672      {
;;;673        icoppositepolarity = TIM_ICPolarity_Rising;
;;;674      }
;;;675      /* Select the Opposite Input */
;;;676      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000014  88a2              LDRH     r2,[r4,#4]
000016  2a01              CMP      r2,#1
000018  d100              BNE      |L65.28|
;;;677      {
;;;678        icoppositeselection = TIM_ICSelection_IndirectTI;
00001a  2602              MOVS     r6,#2
                  |L65.28|
;;;679      }
;;;680      else
;;;681      {
;;;682        icoppositeselection = TIM_ICSelection_DirectTI;
;;;683      }
;;;684      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00001c  8820              LDRH     r0,[r4,#0]
;;;685      {
;;;686        /* TI1 Configuration */
;;;687        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001e  8923              LDRH     r3,[r4,#8]
000020  b190              CBZ      r0,|L65.72|
;;;688                   TIM_ICInitStruct->TIM_ICFilter);
;;;689        /* Set the Input Capture Prescaler value */
;;;690        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;691        /* TI2 Configuration */
;;;692        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;693        /* Set the Input Capture Prescaler value */
;;;694        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;695      }
;;;696      else
;;;697      { 
;;;698        /* TI2 Configuration */
;;;699        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       TI2_Config
;;;700                   TIM_ICInitStruct->TIM_ICFilter);
;;;701        /* Set the Input Capture Prescaler value */
;;;702        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000028  88e1              LDRH     r1,[r4,#6]
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;703        /* TI1 Configuration */
;;;704        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000030  8923              LDRH     r3,[r4,#8]
000032  4632              MOV      r2,r6
000034  4629              MOV      r1,r5
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       TI1_Config
;;;705        /* Set the Input Capture Prescaler value */
;;;706        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00003c  88e1              LDRH     r1,[r4,#6]
00003e  4638              MOV      r0,r7
000040  e8bd41f0          POP      {r4-r8,lr}
000044  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L65.72|
000048  4638              MOV      r0,r7                 ;687
00004a  f7fffffe          BL       TI1_Config
00004e  88e1              LDRH     r1,[r4,#6]            ;690
000050  4638              MOV      r0,r7                 ;690
000052  f7fffffe          BL       TIM_SetIC1Prescaler
000056  8923              LDRH     r3,[r4,#8]            ;692
000058  4632              MOV      r2,r6                 ;692
00005a  4629              MOV      r1,r5                 ;692
00005c  4638              MOV      r0,r7                 ;692
00005e  f7fffffe          BL       TI2_Config
000062  88e1              LDRH     r1,[r4,#6]            ;694
000064  4638              MOV      r0,r7                 ;694
000066  e8bd41f0          POP      {r4-r8,lr}            ;694
00006a  f7ffbffe          B.W      TIM_SetIC2Prescaler
;;;707      }
;;;708    }
;;;709    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1181     */
;;;1182   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1183   {
;;;1184     /* Check the parameters */
;;;1185     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1186     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1187     /* Set the Prescaler value */
;;;1188     TIMx->PSC = Prescaler;
;;;1189     /* Set or reset the UG Bit */
;;;1190     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1191   }
000004  4770              BX       lr
;;;1192   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1463     */
;;;1464   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1465   {
000002  d004              BEQ      |L67.14|
;;;1466     /* Check the parameters */
;;;1467     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1468     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1469     if (NewState != DISABLE)
;;;1470     {
;;;1471       /* Set the CCDS Bit */
;;;1472       TIMx->CR2 |= TIM_CR2_CCDS;
000004  8881              LDRH     r1,[r0,#4]
000006  f0410108          ORR      r1,r1,#8
00000a  8081              STRH     r1,[r0,#4]
;;;1473     }
;;;1474     else
;;;1475     {
;;;1476       /* Reset the CCDS Bit */
;;;1477       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
;;;1478     }
;;;1479   }
00000c  4770              BX       lr
                  |L67.14|
00000e  8881              LDRH     r1,[r0,#4]            ;1477
000010  f0210108          BIC      r1,r1,#8              ;1477
000014  8081              STRH     r1,[r0,#4]            ;1477
000016  4770              BX       lr
;;;1480   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1438     */
;;;1439   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1440   {
000002  d004              BEQ      |L68.14|
;;;1441     /* Check the parameters */
;;;1442     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1443     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1444     if (NewState != DISABLE)
;;;1445     {
;;;1446       /* Set the COM Bit */
;;;1447       TIMx->CR2 |= TIM_CR2_CCUS;
000004  8881              LDRH     r1,[r0,#4]
000006  f0410104          ORR      r1,r1,#4
00000a  8081              STRH     r1,[r0,#4]
;;;1448     }
;;;1449     else
;;;1450     {
;;;1451       /* Reset the COM Bit */
;;;1452       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
;;;1453     }
;;;1454   }
00000c  4770              BX       lr
                  |L68.14|
00000e  8881              LDRH     r1,[r0,#4]            ;1452
000010  f0210104          BIC      r1,r1,#4              ;1452
000014  8081              STRH     r1,[r0,#4]            ;1452
000016  4770              BX       lr
;;;1455   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2149     */
;;;2150   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2151   {
000002  d004              BEQ      |L69.14|
;;;2152     /* Check the parameters */
;;;2153     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2154     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2155     if (NewState != DISABLE)
;;;2156     {
;;;2157       /* Set the TI1S Bit */
;;;2158       TIMx->CR2 |= TIM_CR2_TI1S;
000004  8881              LDRH     r1,[r0,#4]
000006  f0410180          ORR      r1,r1,#0x80
00000a  8081              STRH     r1,[r0,#4]
;;;2159     }
;;;2160     else
;;;2161     {
;;;2162       /* Reset the TI1S Bit */
;;;2163       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
;;;2164     }
;;;2165   }
00000c  4770              BX       lr
                  |L69.14|
00000e  8881              LDRH     r1,[r0,#4]            ;2163
000010  f0210180          BIC      r1,r1,#0x80           ;2163
000014  8081              STRH     r1,[r0,#4]            ;2163
000016  4770              BX       lr
;;;2166   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1234     */
;;;1235   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
;;;1236   {
;;;1237     uint16_t tmpsmcr = 0;
;;;1238     /* Check the parameters */
;;;1239     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1240     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1241     /* Get the TIMx SMCR register value */
;;;1242     tmpsmcr = TIMx->SMCR;
;;;1243     /* Reset the TS Bits */
;;;1244     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000002  f0220270          BIC      r2,r2,#0x70
;;;1245     /* Set the Input Trigger source */
;;;1246     tmpsmcr |= TIM_InputTriggerSource;
000006  430a              ORRS     r2,r2,r1
;;;1247     /* Write to TIMx SMCR */
;;;1248     TIMx->SMCR = tmpsmcr;
000008  8102              STRH     r2,[r0,#8]
;;;1249   }
00000a  4770              BX       lr
;;;1250   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2251     */
;;;2252   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2253   {
;;;2254     /* Check the parameters */
;;;2255     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2256     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2257     /* Reset the MSM Bit */
;;;2258     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000002  f0220280          BIC      r2,r2,#0x80
000006  8102              STRH     r2,[r0,#8]
;;;2259     
;;;2260     /* Set or Reset the MSM Bit */
;;;2261     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2262   }
00000e  4770              BX       lr
;;;2263   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2050     */
;;;2051   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;2052   {
;;;2053     uint32_t tmp = 0;
;;;2054     uint16_t tmp1 = 0;
;;;2055   
;;;2056     /* Check the parameters */
;;;2057     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2058     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2059     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2060   
;;;2061     tmp = (uint32_t) TIMx;
;;;2062     tmp += CCMR_Offset;
000002  f1000318          ADD      r3,r0,#0x18
;;;2063   
;;;2064     tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
000006  2401              MOVS     r4,#1
000008  408c              LSLS     r4,r4,r1
;;;2065   
;;;2066     /* Disable the Channel: Reset the CCxE Bit */
;;;2067     TIMx->CCER &= (uint16_t) ~tmp1;
00000a  8c05              LDRH     r5,[r0,#0x20]
00000c  43a5              BICS     r5,r5,r4
00000e  8405              STRH     r5,[r0,#0x20]
;;;2068   
;;;2069     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000010  2900              CMP      r1,#0
000012  d011              BEQ      |L72.56|
000014  2908              CMP      r1,#8
000016  d00f              BEQ      |L72.56|
;;;2070     {
;;;2071       tmp += (TIM_Channel>>1);
;;;2072   
;;;2073       /* Reset the OCxM bits in the CCMRx register */
;;;2074       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
;;;2075      
;;;2076       /* Configure the OCxM bits in the CCMRx register */
;;;2077       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;2078     }
;;;2079     else
;;;2080     {
;;;2081       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000018  1f09              SUBS     r1,r1,#4
00001a  f3c1004e          UBFX     r0,r1,#1,#15
00001e  4418              ADD      r0,r0,r3
;;;2082   
;;;2083       /* Reset the OCxM bits in the CCMRx register */
;;;2084       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
000020  6801              LDR      r1,[r0,#0]
000022  f42141e0          BIC      r1,r1,#0x7000
000026  6001              STR      r1,[r0,#0]
;;;2085       
;;;2086       /* Configure the OCxM bits in the CCMRx register */
;;;2087       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000028  6801              LDR      r1,[r0,#0]
00002a  f64f73ff          MOV      r3,#0xffff
00002e  ea032202          AND      r2,r3,r2,LSL #8
000032  4311              ORRS     r1,r1,r2
000034  6001              STR      r1,[r0,#0]
;;;2088     }
;;;2089   }
000036  bd30              POP      {r4,r5,pc}
                  |L72.56|
000038  eb030051          ADD      r0,r3,r1,LSR #1       ;2071
00003c  6801              LDR      r1,[r0,#0]            ;2074
00003e  f0210170          BIC      r1,r1,#0x70           ;2074
000042  6001              STR      r1,[r0,#0]            ;2074
000044  6801              LDR      r1,[r0,#0]            ;2077
000046  4311              ORRS     r1,r1,r2              ;2077
000048  6001              STR      r1,[r0,#0]            ;2077
00004a  bd30              POP      {r4,r5,pc}
;;;2090   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2175     */
;;;2176   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2177   {
;;;2178     /* Check the parameters */
;;;2179     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2180     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2181     /* Reset the OPM Bit */
;;;2182     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;2183     /* Configure the OPM Mode */
;;;2184     TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;2185   }
00000e  4770              BX       lr
;;;2186   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2207     */
;;;2208   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2209   {
;;;2210     /* Check the parameters */
;;;2211     assert_param(IS_TIM_LIST7_PERIPH(TIMx));
;;;2212     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2213     /* Reset the MMS Bits */
;;;2214     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000002  f0220270          BIC      r2,r2,#0x70
000006  8082              STRH     r2,[r0,#4]
;;;2215     /* Select the TRGO source */
;;;2216     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;2217   }
00000e  4770              BX       lr
;;;2218   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2230     */
;;;2231   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2232   {
;;;2233     /* Check the parameters */
;;;2234     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2235     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2236    /* Reset the SMS Bits */
;;;2237     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000002  f0220207          BIC      r2,r2,#7
000006  8102              STRH     r2,[r0,#8]
;;;2238     /* Select the Slave Mode */
;;;2239     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2240   }
00000e  4770              BX       lr
;;;2241   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2283     */
;;;2284   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2285   {
;;;2286     /* Check the parameters */
;;;2287     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2288     /* Set the Autoreload Register value */
;;;2289     TIMx->ARR = Autoreload;
;;;2290   }
000002  4770              BX       lr
;;;2291   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2446     */
;;;2447   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2448   {
;;;2449     /* Check the parameters */
;;;2450     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2451     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2452     /* Reset the CKD Bits */
;;;2453     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;2454     /* Set the CKD value */
;;;2455     TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;2456   }
00000e  4770              BX       lr
;;;2457   
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2297     */
;;;2298   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2299   {
;;;2300     /* Check the parameters */
;;;2301     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2302     /* Set the Capture Compare1 Register value */
;;;2303     TIMx->CCR1 = Compare1;
;;;2304   }
000002  4770              BX       lr
;;;2305   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2311     */
;;;2312   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2313   {
;;;2314     /* Check the parameters */
;;;2315     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2316     /* Set the Capture Compare2 Register value */
;;;2317     TIMx->CCR2 = Compare2;
;;;2318   }
000002  4770              BX       lr
;;;2319   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2325     */
;;;2326   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2327   {
;;;2328     /* Check the parameters */
;;;2329     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2330     /* Set the Capture Compare3 Register value */
;;;2331     TIMx->CCR3 = Compare3;
;;;2332   }
000002  4770              BX       lr
;;;2333   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2339     */
;;;2340   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2341   {
;;;2342     /* Check the parameters */
;;;2343     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2344     /* Set the Capture Compare4 Register value */
;;;2345     TIMx->CCR4 = Compare4;
;;;2346   }
000004  4770              BX       lr
;;;2347   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2269     */
;;;2270   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2271   {
;;;2272     /* Check the parameters */
;;;2273     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2274     /* Set the Counter Register value */
;;;2275     TIMx->CNT = Counter;
;;;2276   }
000002  4770              BX       lr
;;;2277   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2358     */
;;;2359   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2360   {
;;;2361     /* Check the parameters */
;;;2362     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2363     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2364     /* Reset the IC1PSC Bits */
;;;2365     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8302              STRH     r2,[r0,#0x18]
;;;2366     /* Set the IC1PSC value */
;;;2367     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;2368   }
00000e  4770              BX       lr
;;;2369   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2380     */
;;;2381   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2382   {
;;;2383     /* Check the parameters */
;;;2384     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2385     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2386     /* Reset the IC2PSC Bits */
;;;2387     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8302              STRH     r2,[r0,#0x18]
;;;2388     /* Set the IC2PSC value */
;;;2389     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  430a              ORRS     r2,r2,r1
000014  8302              STRH     r2,[r0,#0x18]
;;;2390   }
000016  4770              BX       lr
;;;2391   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2402     */
;;;2403   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2404   {
;;;2405     /* Check the parameters */
;;;2406     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2407     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2408     /* Reset the IC3PSC Bits */
;;;2409     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8382              STRH     r2,[r0,#0x1c]
;;;2410     /* Set the IC3PSC value */
;;;2411     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  430a              ORRS     r2,r2,r1
00000c  8382              STRH     r2,[r0,#0x1c]
;;;2412   }
00000e  4770              BX       lr
;;;2413   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2424     */
;;;2425   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2426   {  
;;;2427     /* Check the parameters */
;;;2428     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2429     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2430     /* Reset the IC4PSC Bits */
;;;2431     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8382              STRH     r2,[r0,#0x1c]
;;;2432     /* Set the IC4PSC value */
;;;2433     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  430a              ORRS     r2,r2,r1
000014  8382              STRH     r2,[r0,#0x1c]
;;;2434   }
000016  4770              BX       lr
;;;2435   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1040     */
;;;1041   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b570              PUSH     {r4-r6,lr}
;;;1042                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1043   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  4611              MOV      r1,r2
;;;1044     /* Check the parameters */
;;;1045     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1046     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1047     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1048     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1049     /* Configure the Timer Input Clock Source */
;;;1050     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000008  2d60              CMP      r5,#0x60
00000a  d00c              BEQ      |L87.38|
;;;1051     {
;;;1052       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;1053     }
;;;1054     else
;;;1055     {
;;;1056       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00000c  2201              MOVS     r2,#1
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       TI1_Config
                  |L87.20|
;;;1057     }
;;;1058     /* Select the Trigger source */
;;;1059     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TIM_SelectInputTrigger
;;;1060     /* Select the External clock mode1 */
;;;1061     TIMx->SMCR |= TIM_SlaveMode_External1;
00001c  8920              LDRH     r0,[r4,#8]
00001e  f0400007          ORR      r0,r0,#7
000022  8120              STRH     r0,[r4,#8]
;;;1062   }
000024  bd70              POP      {r4-r6,pc}
                  |L87.38|
000026  2201              MOVS     r2,#1                 ;1052
000028  4620              MOV      r0,r4                 ;1052
00002a  f7fffffe          BL       TI2_Config
00002e  e7f1              B        |L87.20|
;;;1063   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;231      */
;;;232    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;233    {
;;;234      uint16_t tmpcr1 = 0;
;;;235    
;;;236      /* Check the parameters */
;;;237      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;238      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;239      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;240    
;;;241      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;242    
;;;243      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
000004  4c1b              LDR      r4,|L88.116|
000006  4d1c              LDR      r5,|L88.120|
000008  42a0              CMP      r0,r4
00000a  d00d              BEQ      |L88.40|
00000c  42a8              CMP      r0,r5
00000e  d00b              BEQ      |L88.40|
000010  f1b04f80          CMP      r0,#0x40000000
000014  d008              BEQ      |L88.40|
000016  4b19              LDR      r3,|L88.124|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L88.40|
;;;244         (TIMx == TIM4) || (TIMx == TIM5)) 
00001c  4b18              LDR      r3,|L88.128|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L88.40|
000022  4b18              LDR      r3,|L88.132|
000024  4298              CMP      r0,r3
000026  d103              BNE      |L88.48|
                  |L88.40|
;;;245      {
;;;246        /* Select the Counter Mode */
;;;247        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000028  f0220370          BIC      r3,r2,#0x70
;;;248        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00002c  884a              LDRH     r2,[r1,#2]
00002e  431a              ORRS     r2,r2,r3
                  |L88.48|
;;;249      }
;;;250     
;;;251      if((TIMx != TIM6) && (TIMx != TIM7))
000030  4b15              LDR      r3,|L88.136|
000032  4298              CMP      r0,r3
000034  d006              BEQ      |L88.68|
000036  4b15              LDR      r3,|L88.140|
000038  4298              CMP      r0,r3
00003a  d003              BEQ      |L88.68|
;;;252      {
;;;253        /* Set the clock division */
;;;254        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
00003c  f4227340          BIC      r3,r2,#0x300
;;;255        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000040  88ca              LDRH     r2,[r1,#6]
000042  431a              ORRS     r2,r2,r3
                  |L88.68|
;;;256      }
;;;257    
;;;258      TIMx->CR1 = tmpcr1;
000044  8002              STRH     r2,[r0,#0]
;;;259    
;;;260      /* Set the Autoreload value */
;;;261      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000046  888a              LDRH     r2,[r1,#4]
000048  8582              STRH     r2,[r0,#0x2c]
;;;262     
;;;263      /* Set the Prescaler value */
;;;264      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00004a  880a              LDRH     r2,[r1,#0]
00004c  8502              STRH     r2,[r0,#0x28]
;;;265        
;;;266      if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
00004e  42a0              CMP      r0,r4
000050  d00a              BEQ      |L88.104|
000052  42a8              CMP      r0,r5
000054  d008              BEQ      |L88.104|
000056  4a0e              LDR      r2,|L88.144|
000058  4290              CMP      r0,r2
00005a  d005              BEQ      |L88.104|
00005c  4a0d              LDR      r2,|L88.148|
00005e  4290              CMP      r0,r2
000060  d002              BEQ      |L88.104|
000062  4a0d              LDR      r2,|L88.152|
000064  4290              CMP      r0,r2
000066  d101              BNE      |L88.108|
                  |L88.104|
;;;267      {
;;;268        /* Set the Repetition Counter value */
;;;269        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000068  7a09              LDRB     r1,[r1,#8]
00006a  8601              STRH     r1,[r0,#0x30]
                  |L88.108|
;;;270      }
;;;271    
;;;272      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;273         values immediately */
;;;274      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
00006c  2101              MOVS     r1,#1
00006e  8281              STRH     r1,[r0,#0x14]
;;;275    }
000070  bd30              POP      {r4,r5,pc}
;;;276    
                          ENDP

000072  0000              DCW      0x0000
                  |L88.116|
                          DCD      0x40012c00
                  |L88.120|
                          DCD      0x40013400
                  |L88.124|
                          DCD      0x40000400
                  |L88.128|
                          DCD      0x40000800
                  |L88.132|
                          DCD      0x40000c00
                  |L88.136|
                          DCD      0x40001000
                  |L88.140|
                          DCD      0x40001400
                  |L88.144|
                          DCD      0x40014000
                  |L88.148|
                          DCD      0x40014400
                  |L88.152|
                          DCD      0x40014800

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;741      */
;;;742    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;743    {
;;;744      /* Set the default configuration */
;;;745      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;746      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;747      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;748      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;749      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;750    }
000010  4770              BX       lr
;;;751    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2097     */
;;;2098   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2099   {
000002  d004              BEQ      |L90.14|
;;;2100     /* Check the parameters */
;;;2101     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2102     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2103     if (NewState != DISABLE)
;;;2104     {
;;;2105       /* Set the Update Disable Bit */
;;;2106       TIMx->CR1 |= TIM_CR1_UDIS;
000004  8801              LDRH     r1,[r0,#0]
000006  f0410102          ORR      r1,r1,#2
00000a  8001              STRH     r1,[r0,#0]
;;;2107     }
;;;2108     else
;;;2109     {
;;;2110       /* Reset the Update Disable Bit */
;;;2111       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
;;;2112     }
;;;2113   }
00000c  4770              BX       lr
                  |L90.14|
00000e  8801              LDRH     r1,[r0,#0]            ;2111
000010  f0210102          BIC      r1,r1,#2              ;2111
000014  8001              STRH     r1,[r0,#0]            ;2111
000016  4770              BX       lr
;;;2114   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2125     */
;;;2126   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;2127   {
000002  d004              BEQ      |L91.14|
;;;2128     /* Check the parameters */
;;;2129     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2130     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2131     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2132     {
;;;2133       /* Set the URS Bit */
;;;2134       TIMx->CR1 |= TIM_CR1_URS;
000004  8801              LDRH     r1,[r0,#0]
000006  f0410104          ORR      r1,r1,#4
00000a  8001              STRH     r1,[r0,#0]
;;;2135     }
;;;2136     else
;;;2137     {
;;;2138       /* Reset the URS Bit */
;;;2139       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
;;;2140     }
;;;2141   }
00000c  4770              BX       lr
                  |L91.14|
00000e  8801              LDRH     r1,[r0,#0]            ;2139
000010  f0210104          BIC      r1,r1,#4              ;2139
000014  8001              STRH     r1,[r0,#0]            ;2139
000016  4770              BX       lr
;;;2142   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f10x_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
