; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\User_App -I..\..\User\User_Driver -I..\..\User\Font_And_Bmp -I..\..\User\User_GUI -I..\..\User\Util -I.\RTE\_FreeRTOS_STM32F1 -I"D:\Keil MDK\ARM\PACK\ARM\CMSIS\5.5.1\CMSIS\Core\Include" -I"D:\Keil MDK\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=528 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=1

                  ComToUart PROC
;;;93     */
;;;94     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  2800              CMP      r0,#0
;;;95     {
000002  d009              BEQ      |L1.24|
;;;96     	if (_ucPort == COM1)
;;;97     	{
;;;98     		#if UART1_FIFO_EN == 1
;;;99     			return &g_tUart1;
;;;100    		#else
;;;101    			return 0;
;;;102    		#endif
;;;103    	}
;;;104    	else if (_ucPort == COM2)
000004  2801              CMP      r0,#1
000006  d009              BEQ      |L1.28|
;;;105    	{
;;;106    		#if UART2_FIFO_EN == 1
;;;107    			return &g_tUart2;
;;;108    		#else
;;;109    			return 0;
;;;110    		#endif
;;;111    	}
;;;112    	else if (_ucPort == COM3)
000008  2802              CMP      r0,#2
00000a  d009              BEQ      |L1.32|
;;;113    	{
;;;114    		#if UART3_FIFO_EN == 1
;;;115    			return &g_tUart3;
;;;116    		#else
;;;117    			return 0;
;;;118    		#endif
;;;119    	}
;;;120    	else if (_ucPort == COM4)
00000c  2803              CMP      r0,#3
00000e  d009              BEQ      |L1.36|
;;;121    	{
;;;122    		#if UART4_FIFO_EN == 1
;;;123    			return &g_tUart4;
;;;124    		#else
;;;125    			return 0;
;;;126    		#endif
;;;127    	}
;;;128    	else if (_ucPort == COM5)
000010  2804              CMP      r0,#4
000012  d009              BEQ      |L1.40|
;;;129    	{
;;;130    		#if UART5_FIFO_EN == 1
;;;131    			return &g_tUart5;
;;;132    		#else
;;;133    			return 0;
;;;134    		#endif
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		/* 不做任何处理 */
;;;139    		return 0;
000014  2000              MOVS     r0,#0
;;;140    	}
;;;141    }
000016  4770              BX       lr
                  |L1.24|
000018  2000              MOVS     r0,#0                 ;101
00001a  4770              BX       lr
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;109
00001e  4770              BX       lr
                  |L1.32|
000020  2000              MOVS     r0,#0                 ;117
000022  4770              BX       lr
                  |L1.36|
000024  2000              MOVS     r0,#0                 ;125
000026  4770              BX       lr
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;133
00002a  4770              BX       lr
;;;142    
                          ENDP


                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;774    */
;;;775    static void ConfigUartNVIC(void)
000000  4770              BX       lr
;;;776    {
;;;777    	NVIC_InitTypeDef NVIC_InitStructure;
;;;778    
;;;779    	/* Configure the NVIC Preemption Priority Bits */
;;;780    	/*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;781    
;;;782    #if UART1_FIFO_EN == 1
;;;783    	/* 使能串口1中断 */
;;;784    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
;;;785    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;786    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;787    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;788    	NVIC_Init(&NVIC_InitStructure);
;;;789    #endif
;;;790    
;;;791    #if UART2_FIFO_EN == 1
;;;792    	/* 使能串口2中断 */
;;;793    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
;;;794    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;795    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;796    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;797    	NVIC_Init(&NVIC_InitStructure);
;;;798    #endif
;;;799    
;;;800    #if UART3_FIFO_EN == 1
;;;801    	/* 使能串口3中断t */
;;;802    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;803    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;804    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;805    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;806    	NVIC_Init(&NVIC_InitStructure);
;;;807    #endif
;;;808    
;;;809    #if UART4_FIFO_EN == 1
;;;810    	/* 使能串口4中断t */
;;;811    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;812    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;813    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;814    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;815    	NVIC_Init(&NVIC_InitStructure);
;;;816    #endif
;;;817    
;;;818    #if UART5_FIFO_EN == 1
;;;819    	/* 使能串口5中断t */
;;;820    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;821    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;822    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;823    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;824    	NVIC_Init(&NVIC_InitStructure);
;;;825    #endif
;;;826    
;;;827    #if UART6_FIFO_EN == 1
;;;828    	/* 使能串口6中断t */
;;;829    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;830    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;831    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;832    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;833    	NVIC_Init(&NVIC_InitStructure);
;;;834    #endif
;;;835    }
;;;836    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=1

                  InitHardUart PROC
;;;534    */
;;;535    static void InitHardUart(void)
000000  4770              BX       lr
;;;536    {
;;;537    	GPIO_InitTypeDef GPIO_InitStructure;
;;;538    	USART_InitTypeDef USART_InitStructure;
;;;539    
;;;540    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;541    
;;;542    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;543    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
;;;544    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
;;;545    
;;;546    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;547    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
;;;548    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;549    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;550    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;551    
;;;552    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;553    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;554    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;555    	*/
;;;556    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;557    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;558    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;559    	
;;;560    	/* 第4步： 配置串口硬件参数 */
;;;561    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
;;;562    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;563    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;564    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;565    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;566    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;567    	USART_Init(USART1, &USART_InitStructure);
;;;568    
;;;569    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;570    	/*
;;;571    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;572    		注意: 不要在此处打开发送中断
;;;573    		发送中断使能在SendUart()函数打开
;;;574    	*/
;;;575    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
;;;576    
;;;577    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;578    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;579    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;580    #endif
;;;581    
;;;582    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;583    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;584    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
;;;585    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;586    
;;;587    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;588    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;589    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;590    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;591    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;592    
;;;593    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;594    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;595    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;596    	*/
;;;597    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
;;;598    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;599    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;600    	/*  第3步已经做了，因此这步可以不做
;;;601    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;602    	*/
;;;603    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;604    
;;;605    	/* 第4步： 配置串口硬件参数 */
;;;606    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
;;;607    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;608    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;609    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;610    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;611    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
;;;612    	USART_Init(USART2, &USART_InitStructure);
;;;613    
;;;614    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;615    	/*
;;;616    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;617    		注意: 不要在此处打开发送中断
;;;618    		发送中断使能在SendUart()函数打开
;;;619    	*/
;;;620    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
;;;621    
;;;622    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;623    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;624    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;625    #endif
;;;626    
;;;627    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;628    
;;;629    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;630    	{
;;;631    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;632    
;;;633    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;634    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;635    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;636    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;637    	}
;;;638    
;;;639    	/* 第1步： 开启GPIO和UART时钟 */
;;;640    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;641    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;642    
;;;643    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;644    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;645    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;646    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;647    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;648    
;;;649    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;650    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;651    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;652    	*/
;;;653    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;654    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;655    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;656    	/*  第3步已经做了，因此这步可以不做
;;;657    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;658    	*/
;;;659    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;660    
;;;661    	/* 第4步： 配置串口硬件参数 */
;;;662    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;663    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;664    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;665    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;666    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;667    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;668    	USART_Init(USART3, &USART_InitStructure);
;;;669    
;;;670    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;671    	/*
;;;672    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;673    		注意: 不要在此处打开发送中断
;;;674    		发送中断使能在SendUart()函数打开
;;;675    	*/
;;;676    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;677    
;;;678    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;679    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;680    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;681    #endif
;;;682    
;;;683    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;684    	/* 第1步： 开启GPIO和UART时钟 */
;;;685    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;686    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;687    
;;;688    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;689    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;690    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;691    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;692    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;693    
;;;694    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;695    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;696    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;697    	*/
;;;698    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;699    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;700    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;701    
;;;702    	/* 第4步： 配置串口硬件参数 */
;;;703    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
;;;704    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;705    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;706    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;707    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;708    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;709    	USART_Init(UART4, &USART_InitStructure);
;;;710    
;;;711    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;712    	/*
;;;713    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;714    		注意: 不要在此处打开发送中断
;;;715    		发送中断使能在SendUart()函数打开
;;;716    	*/
;;;717    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;718    
;;;719    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;720    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;721    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;722    #endif
;;;723    
;;;724    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;725    	/* 第1步： 开启GPIO和UART时钟 */
;;;726    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
;;;727    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;728    
;;;729    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;730    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;731    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;732    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;733    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;734    
;;;735    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;736    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;737    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;738    	*/
;;;739    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;740    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;741    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;742    
;;;743    
;;;744    	/* 第4步： 配置串口硬件参数 */
;;;745    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;746    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;747    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;748    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;749    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;750    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;751    	USART_Init(UART5, &USART_InitStructure);
;;;752    
;;;753    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;754    	/*
;;;755    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;756    		注意: 不要在此处打开发送中断
;;;757    		发送中断使能在SendUart()函数打开
;;;758    	*/
;;;759    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;760    
;;;761    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;762    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;763    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;764    #endif
;;;765    }
;;;766    
                          ENDP


                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;307    */
;;;308    void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;309    {
;;;310    	GPIO_InitTypeDef GPIO_InitStructure;
;;;311    
;;;312    	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;313    
;;;314    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;315    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;316    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  2004              MOVS     r0,#4
000018  f8ad0000          STRH     r0,[sp,#0]
;;;317    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L4.40|
000020  f7fffffe          BL       GPIO_Init
;;;318    }
000024  bd08              POP      {r3,pc}
;;;319    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40010c00

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;407    //extern void MODBUS_ReciveNew(uint8_t _byte);
;;;408    void RS485_ReciveNew(uint8_t _byte)
000000  4770              BX       lr
;;;409    {
;;;410    //	MODBUS_ReciveNew(_byte);
;;;411    }
;;;412    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;350    */
;;;351    void RS485_SendBefor(void)
000000  4901              LDR      r1,|L6.8|
;;;352    {
;;;353    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  2004              MOVS     r0,#4
000004  6008              STR      r0,[r1,#0]
;;;354    }
000006  4770              BX       lr
;;;355    
                          ENDP

                  |L6.8|
                          DCD      0x40010c10

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;378    */
;;;379    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  460a              MOV      r2,r1
;;;380    {
;;;381    	comSendBuf(COM3, _ucaBuf, _usLen);
000002  4601              MOV      r1,r0
000004  2002              MOVS     r0,#2
000006  f7ffbffe          B.W      comSendBuf
;;;382    }
;;;383    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;364    */
;;;365    void RS485_SendOver(void)
000000  4901              LDR      r1,|L8.8|
;;;366    {
;;;367    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  2004              MOVS     r0,#4
000004  6008              STR      r0,[r1,#0]
;;;368    }
000006  4770              BX       lr
;;;369    
                          ENDP

                  |L8.8|
                          DCD      0x40010c14

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;393    */
;;;394    void RS485_SendStr(char *_pBuf)
000000  b510              PUSH     {r4,lr}
;;;395    {
000002  4604              MOV      r4,r0
;;;396    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b281              UXTH     r1,r0
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      RS485_SendBuf
;;;397    }
;;;398    
                          ENDP


                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;916    */
;;;917    static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;918    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;919    	uint16_t usCount;
;;;920    
;;;921    	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;922    	DISABLE_INT();
000006  f7fffffe          BL       vPortEnterCritical
;;;923    	usCount = _pUart->usRxCount;
00000a  8b65              LDRH     r5,[r4,#0x1a]
;;;924    	ENABLE_INT();
00000c  f7fffffe          BL       vPortExitCritical
;;;925    
;;;926    	/* 如果读和写索引相同，则返回0 */
;;;927    	//if (_pUart->usRxRead == usRxWrite)
;;;928    	if (usCount == 0)	/* 已经没有数据 */
000010  b1ad              CBZ      r5,|L10.62|
;;;929    	{
;;;930    		return 0;
;;;931    	}
;;;932    	else
;;;933    	{
;;;934    		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
000012  8b21              LDRH     r1,[r4,#0x18]
000014  68a0              LDR      r0,[r4,#8]
000016  5c40              LDRB     r0,[r0,r1]
000018  7030              STRB     r0,[r6,#0]
;;;935    
;;;936    		/* 改写FIFO读索引 */
;;;937    		DISABLE_INT();
00001a  f7fffffe          BL       vPortEnterCritical
;;;938    		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
00001e  8b20              LDRH     r0,[r4,#0x18]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  8320              STRH     r0,[r4,#0x18]
000026  89e1              LDRH     r1,[r4,#0xe]
000028  4288              CMP      r0,r1
00002a  d301              BCC      |L10.48|
;;;939    		{
;;;940    			_pUart->usRxRead = 0;
00002c  2000              MOVS     r0,#0
00002e  8320              STRH     r0,[r4,#0x18]
                  |L10.48|
;;;941    		}
;;;942    		_pUart->usRxCount--;
000030  8b60              LDRH     r0,[r4,#0x1a]
000032  1e40              SUBS     r0,r0,#1
000034  8360              STRH     r0,[r4,#0x1a]
;;;943    		ENABLE_INT();
000036  f7fffffe          BL       vPortExitCritical
;;;944    		return 1;
00003a  2001              MOVS     r0,#1
;;;945    	}
;;;946    }
00003c  bd70              POP      {r4-r6,pc}
                  |L10.62|
00003e  2000              MOVS     r0,#0                 ;930
000040  bd70              POP      {r4-r6,pc}
;;;947    
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;844    */
;;;845    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;846    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;847    	uint16_t i;
;;;848    
;;;849    	for (i = 0; i < _usLen; i++)
000008  2500              MOVS     r5,#0
00000a  e015              B        |L11.56|
                  |L11.12|
;;;850    	{
;;;851    		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;852    	#if 0
;;;853    		/*
;;;854    			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;855    			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;856    			将导致while(1) 无法退出
;;;857    		*/
;;;858    		while (1)
;;;859    		{
;;;860    			uint16_t usRead;
;;;861    
;;;862    			DISABLE_INT();
;;;863    			usRead = _pUart->usTxRead;
;;;864    			ENABLE_INT();
;;;865    
;;;866    			if (++usRead >= _pUart->usTxBufSize)
;;;867    			{
;;;868    				usRead = 0;
;;;869    			}
;;;870    
;;;871    			if (usRead != _pUart->usTxWrite)
;;;872    			{
;;;873    				break;
;;;874    			}
;;;875    		}
;;;876    	#else
;;;877    		/* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
;;;878    		while (1)
;;;879    		{
;;;880    			__IO uint16_t usCount;
;;;881    
;;;882    			DISABLE_INT();
;;;883    			usCount = _pUart->usTxCount;
;;;884    			ENABLE_INT();
;;;885    
;;;886    			if (usCount < _pUart->usTxBufSize)
;;;887    			{
;;;888    				break;
;;;889    			}
;;;890    		}
;;;891    	#endif
;;;892    
;;;893    		/* 将新数据填入发送缓冲区 */
;;;894    		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00000c  5d70              LDRB     r0,[r6,r5]
00000e  8a22              LDRH     r2,[r4,#0x10]
000010  6861              LDR      r1,[r4,#4]
000012  5488              STRB     r0,[r1,r2]
;;;895    
;;;896    		DISABLE_INT();
000014  f7fffffe          BL       vPortEnterCritical
;;;897    		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
000018  8a20              LDRH     r0,[r4,#0x10]
00001a  1c40              ADDS     r0,r0,#1
00001c  b280              UXTH     r0,r0
00001e  8220              STRH     r0,[r4,#0x10]
000020  89a1              LDRH     r1,[r4,#0xc]
000022  4288              CMP      r0,r1
000024  d301              BCC      |L11.42|
;;;898    		{
;;;899    			_pUart->usTxWrite = 0;
000026  2000              MOVS     r0,#0
000028  8220              STRH     r0,[r4,#0x10]
                  |L11.42|
;;;900    		}
;;;901    		_pUart->usTxCount++;
00002a  8aa0              LDRH     r0,[r4,#0x14]
00002c  1c40              ADDS     r0,r0,#1
00002e  82a0              STRH     r0,[r4,#0x14]
;;;902    		ENABLE_INT();
000030  f7fffffe          BL       vPortExitCritical
000034  1c6d              ADDS     r5,r5,#1              ;849
000036  b2ad              UXTH     r5,r5                 ;849
                  |L11.56|
000038  42bd              CMP      r5,r7                 ;849
00003a  d20b              BCS      |L11.84|
                  |L11.60|
00003c  f7fffffe          BL       vPortEnterCritical
000040  8aa0              LDRH     r0,[r4,#0x14]         ;883
000042  9000              STR      r0,[sp,#0]            ;883
000044  f7fffffe          BL       vPortExitCritical
000048  89a0              LDRH     r0,[r4,#0xc]          ;886
00004a  f8bd3000          LDRH     r3,[sp,#0]            ;886
00004e  4298              CMP      r0,r3                 ;886
000050  d9f4              BLS      |L11.60|
000052  e7db              B        |L11.12|
                  |L11.84|
;;;903    	}
;;;904    
;;;905    	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
000054  6820              LDR      r0,[r4,#0]
000056  e8bd40f8          POP      {r3-r7,lr}
00005a  2201              MOVS     r2,#1
00005c  f2407127          MOV      r1,#0x727
000060  f7ffbffe          B.W      USART_ITConfig
;;;906    }
;;;907    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=1

                  UartVarInit PROC
;;;420    */
;;;421    static void UartVarInit(void)
000000  4770              BX       lr
;;;422    {
;;;423    #if UART1_FIFO_EN == 1
;;;424    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
;;;425    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
;;;426    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
;;;427    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;428    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;429    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;430    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
;;;431    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;432    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
;;;433    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
;;;434    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
;;;435    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;436    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;437    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;438    #endif
;;;439    
;;;440    #if UART2_FIFO_EN == 1
;;;441    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
;;;442    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
;;;443    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
;;;444    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;445    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;446    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;447    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
;;;448    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;449    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
;;;450    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
;;;451    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
;;;452    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;453    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;454    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;455    #endif
;;;456    
;;;457    #if UART3_FIFO_EN == 1
;;;458    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;459    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;460    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;461    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;462    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;463    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;464    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;465    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;466    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;467    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;468    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
;;;469    	g_tUart3.SendBefor = RS485_SendBefor;		/* 发送数据前的回调函数 */
;;;470    	g_tUart3.SendOver = RS485_SendOver;			/* 发送完毕后的回调函数 */
;;;471    	g_tUart3.ReciveNew = RS485_ReciveNew;		/* 接收到新数据后的回调函数 */
;;;472    #endif
;;;473    
;;;474    #if UART4_FIFO_EN == 1
;;;475    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;476    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;477    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;478    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;479    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;480    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;481    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;482    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;483    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;484    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;485    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;486    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;487    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;488    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;489    #endif
;;;490    
;;;491    #if UART5_FIFO_EN == 1
;;;492    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;493    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;494    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;495    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;496    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;497    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;498    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;499    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;500    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;501    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;502    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;503    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;504    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;505    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;506    #endif
;;;507    
;;;508    
;;;509    #if UART6_FIFO_EN == 1
;;;510    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;511    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;512    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;513    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;514    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;515    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;516    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;517    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;518    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;519    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;520    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;521    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;522    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;523    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;524    #endif
;;;525    }
;;;526    
                          ENDP


                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;74     */
;;;75     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;78     
;;;79     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;80     
;;;81     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
;;;82     
;;;83     	ConfigUartNVIC();	/* 配置串口中断 */
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      ConfigUartNVIC
;;;84     }
;;;85     
                          ENDP


                          AREA ||i.bsp_Set485Baud||, CODE, READONLY, ALIGN=2

                  bsp_Set485Baud PROC
;;;327    */
;;;328    void bsp_Set485Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;329    {
;;;330    	USART_InitTypeDef USART_InitStructure;
;;;331    
;;;332    	/* 第2步： 配置串口硬件参数 */
;;;333    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000002  9000              STR      r0,[sp,#0]
;;;334    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000004  2000              MOVS     r0,#0
000006  f8ad0004          STRH     r0,[sp,#4]
;;;335    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000a  f8ad0006          STRH     r0,[sp,#6]
;;;336    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00000e  f8ad0008          STRH     r0,[sp,#8]
;;;337    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000012  f8ad000c          STRH     r0,[sp,#0xc]
;;;338    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000016  200c              MOVS     r0,#0xc
000018  f8ad000a          STRH     r0,[sp,#0xa]
;;;339    	USART_Init(USART3, &USART_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L14.40|
000020  f7fffffe          BL       USART_Init
;;;340    }
000024  bd1f              POP      {r0-r4,pc}
;;;341    
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      0x40004800

                          AREA ||i.bsp_SetUart1Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart1Baud PROC
;;;260    */
;;;261    void bsp_SetUart1Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;262    {
;;;263    	USART_InitTypeDef USART_InitStructure;
;;;264    
;;;265    	/* 第2步： 配置串口硬件参数 */
;;;266    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000002  9000              STR      r0,[sp,#0]
;;;267    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000004  2000              MOVS     r0,#0
000006  f8ad0004          STRH     r0,[sp,#4]
;;;268    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000a  f8ad0006          STRH     r0,[sp,#6]
;;;269    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00000e  f8ad0008          STRH     r0,[sp,#8]
;;;270    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000012  f8ad000c          STRH     r0,[sp,#0xc]
;;;271    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000016  200c              MOVS     r0,#0xc
000018  f8ad000a          STRH     r0,[sp,#0xa]
;;;272    	USART_Init(USART2, &USART_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L15.40|
000020  f7fffffe          BL       USART_Init
;;;273    }
000024  bd1f              POP      {r0-r4,pc}
;;;274    
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      0x40004400

                          AREA ||i.bsp_SetUart2Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart2Baud PROC
;;;282    */
;;;283    void bsp_SetUart2Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;284    {
;;;285    	USART_InitTypeDef USART_InitStructure;
;;;286    
;;;287    	/* 第2步： 配置串口硬件参数 */
;;;288    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000002  9000              STR      r0,[sp,#0]
;;;289    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000004  2000              MOVS     r0,#0
000006  f8ad0004          STRH     r0,[sp,#4]
;;;290    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000a  f8ad0006          STRH     r0,[sp,#6]
;;;291    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00000e  f8ad0008          STRH     r0,[sp,#8]
;;;292    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000012  f8ad000c          STRH     r0,[sp,#0xc]
;;;293    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000016  200c              MOVS     r0,#0xc
000018  f8ad000a          STRH     r0,[sp,#0xa]
;;;294    	USART_Init(USART2, &USART_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L16.40|
000020  f7fffffe          BL       USART_Init
;;;295    }
000024  bd1f              POP      {r0-r4,pc}
;;;296    
                          ENDP

000026  0000              DCW      0x0000
                  |L16.40|
                          DCD      0x40004400

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;237    */
;;;238    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;239    {
;;;240    	UART_T *pUart;
;;;241    
;;;242    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;243    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L17.18|
;;;244    	{
;;;245    		return;
;;;246    	}
;;;247    
;;;248    	pUart->usRxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  82c1              STRH     r1,[r0,#0x16]
;;;249    	pUart->usRxRead = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;250    	pUart->usRxCount = 0;
000010  8341              STRH     r1,[r0,#0x1a]
                  |L17.18|
;;;251    }
000012  bd00              POP      {pc}
;;;252    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;214    */
;;;215    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;216    {
;;;217    	UART_T *pUart;
;;;218    
;;;219    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;220    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L18.18|
;;;221    	{
;;;222    		return;
;;;223    	}
;;;224    
;;;225    	pUart->usTxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  8201              STRH     r1,[r0,#0x10]
;;;226    	pUart->usTxRead = 0;
00000e  8241              STRH     r1,[r0,#0x12]
;;;227    	pUart->usTxCount = 0;
000010  8281              STRH     r1,[r0,#0x14]
                  |L18.18|
;;;228    }
000012  bd00              POP      {pc}
;;;229    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;193    */
;;;194    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b510              PUSH     {r4,lr}
;;;195    {
;;;196    	UART_T *pUart;
;;;197    
;;;198    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;199    	if (pUart == 0)
000006  b118              CBZ      r0,|L19.16|
;;;200    	{
;;;201    		return 0;
;;;202    	}
;;;203    
;;;204    	return UartGetChar(pUart, _pByte);
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      UartGetChar
                  |L19.16|
000010  2000              MOVS     r0,#0                 ;201
;;;205    }
000012  bd10              POP      {r4,pc}
;;;206    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;152    */
;;;153    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;154    {
000002  460d              MOV      r5,r1
000004  4616              MOV      r6,r2
;;;155    	UART_T *pUart;
;;;156    
;;;157    	pUart = ComToUart(_ucPort);
000006  f7fffffe          BL       ComToUart
00000a  4604              MOV      r4,r0
;;;158    	if (pUart == 0)
00000c  2c00              CMP      r4,#0
00000e  d009              BEQ      |L20.36|
;;;159    	{
;;;160    		return;
;;;161    	}
;;;162    
;;;163    	if (pUart->SendBefor != 0)
000010  69e0              LDR      r0,[r4,#0x1c]
000012  b100              CBZ      r0,|L20.22|
;;;164    	{
;;;165    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
000014  4780              BLX      r0
                  |L20.22|
;;;166    	}
;;;167    
;;;168    	UartSend(pUart, _ucaBuf, _usLen);
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  e8bd4070          POP      {r4-r6,lr}
000020  f7ffbffe          B.W      UartSend
                  |L20.36|
;;;169    }
000024  bd70              POP      {r4-r6,pc}
;;;170    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;179    */
;;;180    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;181    {
;;;182    	comSendBuf(_ucPort, &_ucByte, 1);
000002  2201              MOVS     r2,#1
000004  a901              ADD      r1,sp,#4
000006  f7fffffe          BL       comSendBuf
;;;183    }
00000a  bd1c              POP      {r2-r4,pc}
;;;184    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1123   */
;;;1124   int fgetc(FILE *f)
000000  b508              PUSH     {r3,lr}
                  |L22.2|
;;;1125   {
;;;1126   
;;;1127   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1128   	uint8_t ucData;
;;;1129   
;;;1130   	while(comGetChar(COM1, &ucData) == 0);
000002  4669              MOV      r1,sp
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       comGetChar
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L22.2|
;;;1131   
;;;1132   	return ucData;
00000e  f89d0000          LDRB     r0,[sp,#0]
;;;1133   #else
;;;1134   	/* 等待串口1输入数据 */
;;;1135   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1136   
;;;1137   	return (int)USART_ReceiveData(USART1);
;;;1138   #endif
;;;1139   }
000012  bd08              POP      {r3,pc}
;;;1140   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;1097   */
;;;1098   int fputc(int ch, FILE *f)
000000  b510              PUSH     {r4,lr}
;;;1099   {
000002  4604              MOV      r4,r0
;;;1100   #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1101   	comSendChar(COM1, ch);
000004  b2e1              UXTB     r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       comSendChar
;;;1102   
;;;1103   	return ch;
00000c  4620              MOV      r0,r4
;;;1104   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1105   	/* 写一个字节到USART1 */
;;;1106   	USART_SendData(USART1, (uint8_t) ch);
;;;1107   
;;;1108   	/* 等待发送结束 */
;;;1109   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;1110   	{}
;;;1111   
;;;1112   	return ch;
;;;1113   #endif
;;;1114   }
00000e  bd10              POP      {r4,pc}
;;;1115   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
