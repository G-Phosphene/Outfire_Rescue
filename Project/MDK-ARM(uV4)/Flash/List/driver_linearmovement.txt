; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\driver_linearmovement.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\driver_linearmovement.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\User_App -I..\..\User\User_Driver -I..\..\User\Font_And_Bmp -I..\..\User\User_GUI -I..\..\User\Util -I.\RTE\_FreeRTOS_STM32F1 -I"D:\Keil MDK\ARM\PACK\ARM\CMSIS\5.5.1\CMSIS\Core\Include" -I"D:\Keil MDK\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=528 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\driver_linearmovement.crf ..\..\User\User_Driver\driver_linearMovement.c]
                          THUMB

                          AREA ||i.ADC_Configuration||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;15     */
;;;16     void ADC_Configuration(void)
000000  b530              PUSH     {r4,r5,lr}
;;;17     {
000002  b091              SUB      sp,sp,#0x44
;;;18     //	GPIO_InitTypeDef GPIO_InitStructure;
;;;19     	ADC_InitTypeDef ADC_InitStructure;
;;;20     	__IO uint16_t ADCConvertedValue;
;;;21     
;;;22         /* ADC1  DMA1 Channel Config */  
;;;23         DMA_InitTypeDef DMA_InitStructure;
;;;24         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); //使能DMA时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;25      
;;;26         DMA_DeInit(DMA1_Channel1);   //将DMA的通道1寄存器重设为缺省值：ADC1连接DMA通道1
00000c  4d3e              LDR      r5,|L1.264|
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       DMA_DeInit
;;;27         DMA_InitStructure.DMA_PeripheralBaseAddr =  (u32)&ADC1->DR;  //DMA外设ADC基地址
000014  483d              LDR      r0,|L1.268|
000016  9001              STR      r0,[sp,#4]
;;;28         DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&adc_raw_value;      //DMA内存基地址
000018  483d              LDR      r0,|L1.272|
00001a  9002              STR      r0,[sp,#8]
;;;29         DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  //内存作为数据传输的目的地
00001c  2400              MOVS     r4,#0
00001e  9403              STR      r4,[sp,#0xc]
;;;30         DMA_InitStructure.DMA_BufferSize = 10*4;  //此值为完整一轮DMA传输的次数
000020  2128              MOVS     r1,#0x28
000022  9104              STR      r1,[sp,#0x10]
;;;31         DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  //外设地址不变
000024  9405              STR      r4,[sp,#0x14]
;;;32         DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  //内存地址递增
000026  2180              MOVS     r1,#0x80
000028  9106              STR      r1,[sp,#0x18]
;;;33         DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; //外设数据位宽度16位，即DMA传输尺寸
00002a  0049              LSLS     r1,r1,#1
00002c  9107              STR      r1,[sp,#0x1c]
;;;34         DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; //数据宽度16位
00002e  0088              LSLS     r0,r1,#2
000030  9008              STR      r0,[sp,#0x20]
;;;35         DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;  //工作在循环缓存模式，一轮结束后自动开始下轮传输
000032  2020              MOVS     r0,#0x20
000034  9009              STR      r0,[sp,#0x24]
;;;36         DMA_InitStructure.DMA_Priority = DMA_Priority_High; //DMA通道 x拥有高优先级
000036  0200              LSLS     r0,r0,#8
000038  900a              STR      r0,[sp,#0x28]
;;;37         DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  //DMA通道x禁止内存到内存
00003a  940b              STR      r4,[sp,#0x2c]
;;;38         DMA_Init(DMA1_Channel1, &DMA_InitStructure);  //根据DMA_InitStruct中参数DMA通道
00003c  a901              ADD      r1,sp,#4
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       DMA_Init
;;;39     		DMA_Cmd(DMA1_Channel1, ENABLE);//启动DMA通道
000044  2101              MOVS     r1,#1
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       DMA_Cmd
;;;40         /* 使能 ADC1 and GPIOC clock */
;;;41     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
00004c  2101              MOVS     r1,#1
00004e  0248              LSLS     r0,r1,#9
000050  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;42     
;;;43     	/* 配置IO口为模拟输入 */
;;;44     //	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
;;;45     //	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
;;;46     //	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;47       BSP_GPIO_Init(ADC1_USEGPIO, GPIO_Mode_AIN);
000054  2100              MOVS     r1,#0
000056  482f              LDR      r0,|L1.276|
000058  f7fffffe          BL       BSP_GPIO_Init
;;;48       BSP_GPIO_Init(ADC2_USEGPIO, GPIO_Mode_AIN);
00005c  2100              MOVS     r1,#0
00005e  482e              LDR      r0,|L1.280|
000060  f7fffffe          BL       BSP_GPIO_Init
;;;49       BSP_GPIO_Init(ADC3_USEGPIO, GPIO_Mode_AIN);
000064  2100              MOVS     r1,#0
000066  482d              LDR      r0,|L1.284|
000068  f7fffffe          BL       BSP_GPIO_Init
;;;50       BSP_GPIO_Init(ADC4_USEGPIO, GPIO_Mode_AIN);
00006c  2100              MOVS     r1,#0
00006e  482c              LDR      r0,|L1.288|
000070  f7fffffe          BL       BSP_GPIO_Init
;;;51     
;;;52     	/* 配置ADC1, 不用DMA, 用软件触发 */
;;;53     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000074  940c              STR      r4,[sp,#0x30]
;;;54     	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
000076  2001              MOVS     r0,#1
000078  f88d0034          STRB     r0,[sp,#0x34]
;;;55     	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
00007c  f88d0035          STRB     r0,[sp,#0x35]
;;;56     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
000080  f44f2060          MOV      r0,#0xe0000
000084  900e              STR      r0,[sp,#0x38]
;;;57     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000086  940f              STR      r4,[sp,#0x3c]
;;;58     	ADC_InitStructure.ADC_NbrOfChannel = 2;
000088  2002              MOVS     r0,#2
00008a  f88d0040          STRB     r0,[sp,#0x40]
;;;59     	
;;;60     	ADC_Init(ADC1, &ADC_InitStructure);
00008e  4c1f              LDR      r4,|L1.268|
000090  a90c              ADD      r1,sp,#0x30
000092  3c4c              SUBS     r4,r4,#0x4c
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       ADC_Init
;;;61     
;;;62     	/* 配置ADC1 规则通道14 channel14 configuration */
;;;63     	ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_55Cycles5);
00009a  2305              MOVS     r3,#5
00009c  2201              MOVS     r2,#1
00009e  210a              MOVS     r1,#0xa
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       ADC_RegularChannelConfig
;;;64     	ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 2, ADC_SampleTime_55Cycles5);
0000a6  2305              MOVS     r3,#5
0000a8  2202              MOVS     r2,#2
0000aa  210b              MOVS     r1,#0xb
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       ADC_RegularChannelConfig
;;;65     	ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 3, ADC_SampleTime_55Cycles5);
0000b2  2305              MOVS     r3,#5
0000b4  2203              MOVS     r2,#3
0000b6  210c              MOVS     r1,#0xc
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       ADC_RegularChannelConfig
;;;66     	ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 4, ADC_SampleTime_55Cycles5);
0000be  2305              MOVS     r3,#5
0000c0  2204              MOVS     r2,#4
0000c2  210d              MOVS     r1,#0xd
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       ADC_RegularChannelConfig
;;;67     
;;;68     	/* 使能ADC1 DMA功能 */
;;;69     	ADC_DMACmd(ADC1, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       ADC_DMACmd
;;;70     
;;;71     	/* 使能 ADC1 */
;;;72     	ADC_Cmd(ADC1, ENABLE);
0000d2  2101              MOVS     r1,#1
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       ADC_Cmd
;;;73     
;;;74     	/* 使能ADC1 复位校准寄存器 */
;;;75     	ADC_ResetCalibration(ADC1);
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       ADC_ResetCalibration
                  |L1.224|
;;;76     	/* 检查ADC1的复位寄存器 */
;;;77     	while(ADC_GetResetCalibrationStatus(ADC1));
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000e6  2800              CMP      r0,#0
0000e8  d1fa              BNE      |L1.224|
;;;78     
;;;79     	/* 启动ADC1校准 */
;;;80     	ADC_StartCalibration(ADC1);
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       ADC_StartCalibration
                  |L1.240|
;;;81     	/* 检查校准是否结束 */
;;;82     	while(ADC_GetCalibrationStatus(ADC1));
0000f0  4620              MOV      r0,r4
0000f2  f7fffffe          BL       ADC_GetCalibrationStatus
0000f6  2800              CMP      r0,#0
0000f8  d1fa              BNE      |L1.240|
;;;83     
;;;84     	/* 软件启动ADC转换 */
;;;85     	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0000fa  2101              MOVS     r1,#1
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;86     }
000102  b011              ADD      sp,sp,#0x44
000104  bd30              POP      {r4,r5,pc}
;;;87     
                          ENDP

000106  0000              DCW      0x0000
                  |L1.264|
                          DCD      0x40020008
                  |L1.268|
                          DCD      0x4001244c
                  |L1.272|
                          DCD      ||.bss||+0x28
                  |L1.276|
                          DCD      BSP_GPIOC0_Base
                  |L1.280|
                          DCD      BSP_GPIOC1_Base
                  |L1.284|
                          DCD      BSP_GPIOC2_Base
                  |L1.288|
                          DCD      BSP_GPIOC3_Base

                          AREA ||i.AdcPro||, CODE, READONLY, ALIGN=2

                  AdcPro PROC
;;;95     */
;;;96     void AdcPro(void)
000000  b570              PUSH     {r4-r6,lr}
;;;97     {
;;;98     	static uint16_t buf[SAMP_COUNT];
;;;99     	static uint8_t write;
;;;100    	uint32_t sum;
;;;101    	uint8_t i;
;;;102    
;;;103    	buf[write] = ADC_GetConversionValue(ADC1);
000002  4c12              LDR      r4,|L2.76|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       ADC_GetConversionValue
00000a  4d12              LDR      r5,|L2.84|
00000c  4601              MOV      r1,r0
00000e  4b10              LDR      r3,|L2.80|
000010  7828              LDRB     r0,[r5,#0]  ; write
000012  f8231010          STRH     r1,[r3,r0,LSL #1]
;;;104    	if (++write >= SAMP_COUNT)
000016  1c40              ADDS     r0,r0,#1
000018  b2c0              UXTB     r0,r0
00001a  7028              STRB     r0,[r5,#0]
00001c  2814              CMP      r0,#0x14
00001e  d301              BCC      |L2.36|
;;;105    	{
;;;106    		write = 0;
000020  2000              MOVS     r0,#0
000022  7028              STRB     r0,[r5,#0]
                  |L2.36|
;;;107    	}
;;;108    
;;;109    	/* 下面这段代码采用求平均值的方法进行滤波
;;;110    		也可以改善下，选择去掉最大和最下2个值，使数据更加精确
;;;111    	*/
;;;112    	sum = 0;
000024  2200              MOVS     r2,#0
;;;113    	for (i = 0; i < SAMP_COUNT; i++)
000026  2100              MOVS     r1,#0
                  |L2.40|
;;;114    	{
;;;115    		sum += buf[i];
000028  f8330011          LDRH     r0,[r3,r1,LSL #1]
00002c  4402              ADD      r2,r2,r0
00002e  1c49              ADDS     r1,r1,#1              ;113
000030  b2c9              UXTB     r1,r1                 ;113
000032  2914              CMP      r1,#0x14              ;113
000034  d3f8              BCC      |L2.40|
;;;116    	}
;;;117    	g_usAdcValue = sum / SAMP_COUNT;	/* ADC采样值由若干次采样值平均 */
000036  2014              MOVS     r0,#0x14
000038  fbb2f0f0          UDIV     r0,r2,r0
00003c  8068              STRH     r0,[r5,#2]
;;;118    
;;;119    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);	/* 软件启动下次ADC转换 */
00003e  4620              MOV      r0,r4
000040  e8bd4070          POP      {r4-r6,lr}
000044  2101              MOVS     r1,#1
000046  f7ffbffe          B.W      ADC_SoftwareStartConvCmd
;;;120    }
;;;121    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x40012400
                  |L2.80|
                          DCD      ||.bss||
                  |L2.84|
                          DCD      ||.data||

                          AREA ||i.GetADC||, CODE, READONLY, ALIGN=2

                  GetADC PROC
;;;129    */
;;;130    uint16_t GetADC(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
;;;131    {
;;;132    	uint16_t ret;
;;;133    
;;;134    	/* 因为	g_AdcValue 变量在systick中断中改写，为了避免主程序读变量时被中断程序打乱导致数据错误，因此需要
;;;135    	关闭中断进行保护 */
;;;136    
;;;137    	/* 进行临界区保护，关闭中断 */
;;;138    	__set_PRIMASK(1);  /* 关中断 */
;;;139    
;;;140    	ret = g_usAdcValue;
000006  4803              LDR      r0,|L3.20|
000008  8840              LDRH     r0,[r0,#2]  ; g_usAdcValue
;;;141    
;;;142    	__set_PRIMASK(0);  /* 开中断 */
00000a  2100              MOVS     r1,#0
00000c  f3818810          MSR      PRIMASK,r1
;;;143    
;;;144    	return ret;
;;;145    }
000010  4770              BX       lr
;;;146    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.adcFilter||, CODE, READONLY, ALIGN=1

                  adcFilter PROC
;;;241    
;;;242    float adcFilter(float input, struct adcFilterData *filterParameters) //二阶低通滤波
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;243    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;244        float output;
;;;245    
;;;246        output = filterParameters->gx1 * input +
000008  6921              LDR      r1,[r4,#0x10]
00000a  68a0              LDR      r0,[r4,#8]
00000c  f7fffffe          BL       __aeabi_fmul
000010  4606              MOV      r6,r0
000012  68e1              LDR      r1,[r4,#0xc]
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       __aeabi_fmul
00001a  4607              MOV      r7,r0
00001c  4628              MOV      r0,r5
00001e  6821              LDR      r1,[r4,#0]
000020  f7fffffe          BL       __aeabi_fmul
000024  4639              MOV      r1,r7
000026  f7fffffe          BL       __aeabi_fadd
00002a  4631              MOV      r1,r6
00002c  f7fffffe          BL       __aeabi_fsub
;;;247                 filterParameters->gx2 * filterParameters->previousInput -
;;;248                 filterParameters->gx3 * filterParameters->previousOutput;
;;;249    
;;;250        filterParameters->previousInput  = input;
000030  60e5              STR      r5,[r4,#0xc]
;;;251        filterParameters->previousOutput = output;
000032  6120              STR      r0,[r4,#0x10]
;;;252    
;;;253        return output;
;;;254    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;255    
                          ENDP


                          AREA ||i.adcLowPassFilter||, CODE, READONLY, ALIGN=2

                  adcLowPassFilter PROC
;;;255    
;;;256    void adcLowPassFilter(formatTrans32Struct_t *distence, formatTrans32Struct_t *speed)  //获得最终距离和速度值
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;257    {
000004  4605              MOV      r5,r0
;;;258    	int i;
;;;259    	getadc_average(average_dis);
000006  480d              LDR      r0,|L5.60|
000008  f7fffffe          BL       getadc_average
;;;260    	  
;;;261      for(i = 0; i<2; i++)
00000c  2400              MOVS     r4,#0
00000e  4e0b              LDR      r6,|L5.60|
;;;262    	{
;;;263    	  distence[i].float_temp = (adcFilter(average_dis[i] , &adcFilters[i]));//mm
000010  f1060710          ADD      r7,r6,#0x10
                  |L5.20|
000014  eb040084          ADD      r0,r4,r4,LSL #2
000018  eb070180          ADD      r1,r7,r0,LSL #2
00001c  f8560024          LDR      r0,[r6,r4,LSL #2]
000020  f7fffffe          BL       adcFilter
000024  f8450024          STR      r0,[r5,r4,LSL #2]
000028  1c64              ADDS     r4,r4,#1              ;261
00002a  2c02              CMP      r4,#2                 ;261
00002c  dbf2              BLT      |L5.20|
;;;264    	}
;;;265    	  distence[1].float_temp += 0.2f;
00002e  4904              LDR      r1,|L5.64|
000030  6868              LDR      r0,[r5,#4]
000032  f7fffffe          BL       __aeabi_fadd
000036  6068              STR      r0,[r5,#4]
;;;266    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;267    
                          ENDP

                  |L5.60|
                          DCD      ||.bss||+0x78
                  |L5.64|
                          DCD      0x3e4ccccd

                          AREA ||i.adcLowPassFilterInit||, CODE, READONLY, ALIGN=2

                  adcLowPassFilterInit PROC
;;;164    
;;;165    void adcLowPassFilterInit(void)  //低通滤波参数初始化
000000  4923              LDR      r1,|L6.144|
;;;166    {
;;;167    		float a;
;;;168    /**********************  ADC_1 *******************************/
;;;169    
;;;170        a = 2.0f * 0.05f * 200.0f;
;;;171    
;;;172        adcFilters[ADC_1].gx1 = 1.0f / (1.0f + a);
000002  4822              LDR      r0,|L6.140|
000004  6008              STR      r0,[r1,#0]  ; adcFilters
;;;173        adcFilters[ADC_1].gx2 = 1.0f / (1.0f + a);
000006  6048              STR      r0,[r1,#4]  ; adcFilters
;;;174        adcFilters[ADC_1].gx3 = (1.0f - a) / (1.0f + a);
000008  4822              LDR      r0,|L6.148|
00000a  6088              STR      r0,[r1,#8]  ; adcFilters
;;;175        adcFilters[ADC_1].previousInput  = 0.0f;
00000c  2000              MOVS     r0,#0
00000e  60c8              STR      r0,[r1,#0xc]  ; adcFilters
;;;176        adcFilters[ADC_1].previousOutput = 0.0f;
000010  6108              STR      r0,[r1,#0x10]  ; adcFilters
;;;177    		
;;;178    /**********************  ADC_2 *******************************/
;;;179        a = 2.0f * 0.05f * 200.0f;
;;;180    
;;;181        adcFilters[ADC_2].gx1 = 1.0f / (1.0f + a);
000012  481e              LDR      r0,|L6.140|
000014  6148              STR      r0,[r1,#0x14]  ; adcFilters
;;;182        adcFilters[ADC_2].gx2 = 1.0f / (1.0f + a);
000016  6188              STR      r0,[r1,#0x18]  ; adcFilters
;;;183        adcFilters[ADC_2].gx3 = (1.0f - a) / (1.0f + a);
000018  481e              LDR      r0,|L6.148|
00001a  61c8              STR      r0,[r1,#0x1c]  ; adcFilters
;;;184        adcFilters[ADC_2].previousInput  = 0.0f;
00001c  2000              MOVS     r0,#0
00001e  6208              STR      r0,[r1,#0x20]  ; adcFilters
;;;185        adcFilters[ADC_2].previousOutput = 0.0f;		
000020  6248              STR      r0,[r1,#0x24]  ; adcFilters
;;;186    /**********************  ADC_3 *******************************/
;;;187        a = 2.0f * 0.3f * 1000.0f;
;;;188    
;;;189        adcFilters[ADC_3].gx1 = 1.0f / (1.0f + a);
000022  4a1d              LDR      r2,|L6.152|
000024  628a              STR      r2,[r1,#0x28]  ; adcFilters
;;;190        adcFilters[ADC_3].gx2 = 1.0f / (1.0f + a);
000026  62ca              STR      r2,[r1,#0x2c]  ; adcFilters
;;;191        adcFilters[ADC_3].gx3 = (1.0f - a) / (1.0f + a);
000028  481c              LDR      r0,|L6.156|
00002a  6308              STR      r0,[r1,#0x30]  ; adcFilters
;;;192        adcFilters[ADC_3].previousInput  = 0.0f;
00002c  2000              MOVS     r0,#0
00002e  6348              STR      r0,[r1,#0x34]  ; adcFilters
;;;193        adcFilters[ADC_3].previousOutput = 0.0f;		
000030  6388              STR      r0,[r1,#0x38]  ; adcFilters
;;;194    		
;;;195    /**********************  ADC_4 *******************************/
;;;196        a = 2.0f * 0.3f * 1000.0f;
;;;197    
;;;198        adcFilters[ADC_4].gx1 = 1.0f / (1.0f + a);
000032  63ca              STR      r2,[r1,#0x3c]  ; adcFilters
;;;199        adcFilters[ADC_4].gx2 = 1.0f / (1.0f + a);
000034  640a              STR      r2,[r1,#0x40]  ; adcFilters
;;;200        adcFilters[ADC_4].gx3 = (1.0f - a) / (1.0f + a);
000036  4819              LDR      r0,|L6.156|
000038  6448              STR      r0,[r1,#0x44]  ; adcFilters
;;;201        adcFilters[ADC_4].previousInput  = 0.0f;
00003a  2000              MOVS     r0,#0
00003c  6488              STR      r0,[r1,#0x48]  ; adcFilters
;;;202        adcFilters[ADC_4].previousOutput = 0.0f;		
00003e  64c8              STR      r0,[r1,#0x4c]  ; adcFilters
;;;203    		
;;;204    		
;;;205    		/**********************  SPEED_1 *******************************/
;;;206    
;;;207        a = 2.0f * 0.05f * 500.0f;
;;;208    
;;;209        speedFilters[SPEED_1].gx1 = 1.0f / (1.0f + a);
000040  3150              ADDS     r1,r1,#0x50
000042  4a17              LDR      r2,|L6.160|
000044  600a              STR      r2,[r1,#0]  ; speedFilters
;;;210        speedFilters[SPEED_1].gx2 = 1.0f / (1.0f + a);
000046  604a              STR      r2,[r1,#4]  ; speedFilters
;;;211        speedFilters[SPEED_1].gx3 = (1.0f - a) / (1.0f + a);
000048  4b16              LDR      r3,|L6.164|
00004a  608b              STR      r3,[r1,#8]  ; speedFilters
;;;212        speedFilters[SPEED_1].previousInput  = 0.0f;
00004c  4810              LDR      r0,|L6.144|
00004e  2100              MOVS     r1,#0
000050  3050              ADDS     r0,r0,#0x50
000052  60c1              STR      r1,[r0,#0xc]  ; speedFilters
;;;213        speedFilters[SPEED_1].previousOutput = 0.0f;
000054  490e              LDR      r1,|L6.144|
000056  2000              MOVS     r0,#0
000058  3150              ADDS     r1,r1,#0x50
00005a  6108              STR      r0,[r1,#0x10]  ; speedFilters
;;;214    		
;;;215    /**********************  SPEED_2 *******************************/
;;;216        a = 2.0f * 0.05f * 500.0f;
;;;217    
;;;218        speedFilters[SPEED_2].gx1 = 1.0f / (1.0f + a);
00005c  614a              STR      r2,[r1,#0x14]  ; speedFilters
;;;219        speedFilters[SPEED_2].gx2 = 1.0f / (1.0f + a);
00005e  618a              STR      r2,[r1,#0x18]  ; speedFilters
;;;220        speedFilters[SPEED_2].gx3 = (1.0f - a) / (1.0f + a);
000060  61cb              STR      r3,[r1,#0x1c]  ; speedFilters
;;;221        speedFilters[SPEED_2].previousInput  = 0.0f;
000062  6208              STR      r0,[r1,#0x20]  ; speedFilters
;;;222        speedFilters[SPEED_2].previousOutput = 0.0f;		
000064  6248              STR      r0,[r1,#0x24]  ; speedFilters
;;;223    /**********************  SPEED_3 *******************************/
;;;224        a = 2.0f * 0.05f * 1000.0f;
;;;225    
;;;226        speedFilters[SPEED_3].gx1 = 1.0f / (1.0f + a);
000066  4a10              LDR      r2,|L6.168|
000068  628a              STR      r2,[r1,#0x28]  ; speedFilters
;;;227        speedFilters[SPEED_3].gx2 = 1.0f / (1.0f + a);
00006a  62ca              STR      r2,[r1,#0x2c]  ; speedFilters
;;;228        speedFilters[SPEED_3].gx3 = (1.0f - a) / (1.0f + a);
00006c  4b0f              LDR      r3,|L6.172|
00006e  630b              STR      r3,[r1,#0x30]  ; speedFilters
;;;229        speedFilters[SPEED_3].previousInput  = 0.0f;
000070  6348              STR      r0,[r1,#0x34]  ; speedFilters
;;;230        speedFilters[SPEED_3].previousOutput = 0.0f;		
000072  4807              LDR      r0,|L6.144|
000074  2100              MOVS     r1,#0
000076  3050              ADDS     r0,r0,#0x50
000078  6381              STR      r1,[r0,#0x38]  ; speedFilters
;;;231    		
;;;232    /**********************  SPEED_4 *******************************/
;;;233        a = 2.0f * 0.05f * 1000.0f;
;;;234    
;;;235        speedFilters[SPEED_4].gx1 = 1.0f / (1.0f + a);
00007a  4601              MOV      r1,r0
00007c  63ca              STR      r2,[r1,#0x3c]  ; speedFilters
;;;236        speedFilters[SPEED_4].gx2 = 1.0f / (1.0f + a);
00007e  640a              STR      r2,[r1,#0x40]  ; speedFilters
;;;237        speedFilters[SPEED_4].gx3 = (1.0f - a) / (1.0f + a);
000080  644b              STR      r3,[r1,#0x44]  ; speedFilters
;;;238        speedFilters[SPEED_4].previousInput  = 0.0f;
000082  2000              MOVS     r0,#0
000084  6488              STR      r0,[r1,#0x48]  ; speedFilters
;;;239        speedFilters[SPEED_4].previousOutput = 0.0f;		
000086  64c8              STR      r0,[r1,#0x4c]  ; speedFilters
;;;240    }
000088  4770              BX       lr
;;;241    
                          ENDP

00008a  0000              DCW      0x0000
                  |L6.140|
                          DCD      0x3d430c31
                  |L6.144|
                          DCD      ||.bss||+0x88
                  |L6.148|
                          DCD      0xbf679e7a
                  |L6.152|
                          DCD      0x3ada1700
                  |L6.156|
                          DCD      0xbf7f25e9
                  |L6.160|
                          DCD      0x3ca0a0a1
                  |L6.164|
                          DCD      0xbf75f5f6
                  |L6.168|
                          DCD      0x3c2237c3
                  |L6.172|
                          DCD      0xbf7aee42

                          AREA ||i.getadc_average||, CODE, READONLY, ALIGN=2

                  getadc_average PROC
;;;148    
;;;149    void getadc_average(__IO float *real)  //采集得到平均值
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;150    {
000004  4680              MOV      r8,r0
;;;151    	int i;
;;;152    	int j;
;;;153    	float sum =0;
000006  2600              MOVS     r6,#0
;;;154    	for (i = 0; i < 2; i++)
000008  2500              MOVS     r5,#0
;;;155    	{
;;;156    		for (j = 0; j < 10;j++)
;;;157    		{
;;;158    			sum += adc_raw_value[j][i];
00000a  4f11              LDR      r7,|L7.80|
                  |L7.12|
00000c  2400              MOVS     r4,#0                 ;156
                  |L7.14|
00000e  eb0700c4          ADD      r0,r7,r4,LSL #3
000012  f8300015          LDRH     r0,[r0,r5,LSL #1]
000016  f7fffffe          BL       __aeabi_ui2f
00001a  4631              MOV      r1,r6
00001c  f7fffffe          BL       __aeabi_fadd
000020  4606              MOV      r6,r0
000022  1c64              ADDS     r4,r4,#1              ;156
000024  2c0a              CMP      r4,#0xa               ;156
000026  dbf2              BLT      |L7.14|
;;;159    		}
;;;160    		real[i] = sum * 0.1f * SENSOR_SCALE;//mm  
000028  490a              LDR      r1,|L7.84|
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       __aeabi_fmul
000030  f06f010b          MVN      r1,#0xb
000034  f7fffffe          BL       __ARM_scalbnf
000038  4907              LDR      r1,|L7.88|
00003a  f7fffffe          BL       __aeabi_fmul
00003e  f8480025          STR      r0,[r8,r5,LSL #2]
;;;161    		sum=0;
000042  2600              MOVS     r6,#0
000044  1c6d              ADDS     r5,r5,#1              ;154
000046  2d02              CMP      r5,#2                 ;154
000048  dbe0              BLT      |L7.12|
;;;162      }
;;;163    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;164    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      ||.bss||+0x28
                  |L7.84|
                          DCD      0x3dcccccd
                  |L7.88|
                          DCD      0x43fa0000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  buf
                          %        40
                  adc_raw_value
                          %        80
                  average_dis
                          %        16
                  adcFilters
                          %        80
                  speedFilters
                          %        80

                          AREA ||.data||, DATA, ALIGN=1

                  write
000000  0000              DCB      0x00,0x00
                  g_usAdcValue
000002  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\User_Driver\\driver_linearMovement.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_driver_linearMovement_c_5ab123b8____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___23_driver_linearMovement_c_5ab123b8____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_driver_linearMovement_c_5ab123b8____REVSH|
#line 128
|__asm___23_driver_linearMovement_c_5ab123b8____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
