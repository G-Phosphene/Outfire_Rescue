; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\system_stm32f10x.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\User_App -I..\..\User\User_Driver -I..\..\User\Font_And_Bmp -I..\..\User\User_GUI -I..\..\User\Util -I.\RTE\_FreeRTOS_STM32F1 -I"D:\Keil MDK\ARM\PACK\ARM\CMSIS\5.5.1\CMSIS\Core\Include" -I"D:\Keil MDK\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=528 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\system_stm32f10x.crf ..\..\User\bsp\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=1

                  SetSysClock PROC
;;;424      */
;;;425    static void SetSysClock(void)
000000  f7ffbffe          B.W      SetSysClockTo72
;;;426    {
;;;427    #ifdef SYSCLK_FREQ_HSE
;;;428      SetSysClockToHSE();
;;;429    #elif defined SYSCLK_FREQ_24MHz
;;;430      SetSysClockTo24();
;;;431    #elif defined SYSCLK_FREQ_36MHz
;;;432      SetSysClockTo36();
;;;433    #elif defined SYSCLK_FREQ_48MHz
;;;434      SetSysClockTo48();
;;;435    #elif defined SYSCLK_FREQ_56MHz
;;;436      SetSysClockTo56();  
;;;437    #elif defined SYSCLK_FREQ_72MHz
;;;438      SetSysClockTo72();
;;;439    #endif
;;;440     
;;;441     /* If none of the define above is enabled, the HSI is used as System clock
;;;442        source (default after reset) */ 
;;;443    }
;;;444    
                          ENDP


                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;992      */
;;;993    static void SetSysClockTo72(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;994    {
;;;995      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2200              MOVS     r2,#0
000004  9201              STR      r2,[sp,#4]
000006  9200              STR      r2,[sp,#0]
;;;996      
;;;997      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;998      /* Enable HSE */    
;;;999      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000008  4827              LDR      r0,|L2.168|
00000a  6801              LDR      r1,[r0,#0]
00000c  f4413180          ORR      r1,r1,#0x10000
000010  6001              STR      r1,[r0,#0]
;;;1000    
;;;1001     /* Wait till HSE is ready and if Time out is reached exit */
;;;1002     do
;;;1003     {
;;;1004       HSEStatus = RCC->CR & RCC_CR_HSERDY;
;;;1005       StartUpCounter++;  
;;;1006     } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000012  f44f63a0          MOV      r3,#0x500
                  |L2.22|
000016  6801              LDR      r1,[r0,#0]            ;1004
000018  f4013100          AND      r1,r1,#0x20000        ;1004
00001c  9100              STR      r1,[sp,#0]            ;1004
00001e  9901              LDR      r1,[sp,#4]            ;1005
000020  1c49              ADDS     r1,r1,#1              ;1005
000022  9101              STR      r1,[sp,#4]            ;1005
000024  9900              LDR      r1,[sp,#0]
000026  b911              CBNZ     r1,|L2.46|
000028  9901              LDR      r1,[sp,#4]
00002a  4299              CMP      r1,r3
00002c  d1f3              BNE      |L2.22|
                  |L2.46|
;;;1007   
;;;1008     if ((RCC->CR & RCC_CR_HSERDY) != RESET)
00002e  6801              LDR      r1,[r0,#0]
000030  0389              LSLS     r1,r1,#14
000032  d502              BPL      |L2.58|
;;;1009     {
;;;1010       HSEStatus = (uint32_t)0x01;
000034  2101              MOVS     r1,#1
000036  9100              STR      r1,[sp,#0]
000038  e000              B        |L2.60|
                  |L2.58|
;;;1011     }
;;;1012     else
;;;1013     {
;;;1014       HSEStatus = (uint32_t)0x00;
00003a  9200              STR      r2,[sp,#0]
                  |L2.60|
;;;1015     }  
;;;1016   
;;;1017     if (HSEStatus == (uint32_t)0x01)
00003c  9900              LDR      r1,[sp,#0]
00003e  2901              CMP      r1,#1
000040  d130              BNE      |L2.164|
;;;1018     {
;;;1019       /* Enable Prefetch Buffer */
;;;1020       FLASH->ACR |= FLASH_ACR_PRFTBE;
000042  491a              LDR      r1,|L2.172|
000044  680a              LDR      r2,[r1,#0]
000046  f0420210          ORR      r2,r2,#0x10
00004a  600a              STR      r2,[r1,#0]
;;;1021   
;;;1022       /* Flash 2 wait state */
;;;1023       FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
00004c  680a              LDR      r2,[r1,#0]
00004e  f0220203          BIC      r2,r2,#3
000052  600a              STR      r2,[r1,#0]
;;;1024       FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000054  680a              LDR      r2,[r1,#0]
000056  f0420202          ORR      r2,r2,#2
00005a  600a              STR      r2,[r1,#0]
;;;1025   
;;;1026    
;;;1027       /* HCLK = SYSCLK */
;;;1028       RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00005c  6841              LDR      r1,[r0,#4]
00005e  6041              STR      r1,[r0,#4]
;;;1029         
;;;1030       /* PCLK2 = HCLK */
;;;1031       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000060  6841              LDR      r1,[r0,#4]
000062  6041              STR      r1,[r0,#4]
;;;1032       
;;;1033       /* PCLK1 = HCLK */
;;;1034       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
000064  6841              LDR      r1,[r0,#4]
000066  f4416180          ORR      r1,r1,#0x400
00006a  6041              STR      r1,[r0,#4]
;;;1035   
;;;1036   #ifdef STM32F10X_CL
;;;1037       /* Configure PLLs ------------------------------------------------------*/
;;;1038       /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;1039       /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;1040           
;;;1041       RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;1042                                 RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;1043       RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;1044                                RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;1045     
;;;1046       /* Enable PLL2 */
;;;1047       RCC->CR |= RCC_CR_PLL2ON;
;;;1048       /* Wait till PLL2 is ready */
;;;1049       while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;1050       {
;;;1051       }
;;;1052       
;;;1053      
;;;1054       /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;1055       RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;1056       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;1057                               RCC_CFGR_PLLMULL9); 
;;;1058   #else    
;;;1059       /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;1060       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
00006c  6841              LDR      r1,[r0,#4]
00006e  f421117c          BIC      r1,r1,#0x3f0000
000072  6041              STR      r1,[r0,#4]
;;;1061                                           RCC_CFGR_PLLMULL));
;;;1062       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
000074  6841              LDR      r1,[r0,#4]
000076  f44111e8          ORR      r1,r1,#0x1d0000
00007a  6041              STR      r1,[r0,#4]
;;;1063   #endif /* STM32F10X_CL */
;;;1064   
;;;1065       /* Enable PLL */
;;;1066       RCC->CR |= RCC_CR_PLLON;
00007c  6801              LDR      r1,[r0,#0]
00007e  f0417180          ORR      r1,r1,#0x1000000
000082  6001              STR      r1,[r0,#0]
                  |L2.132|
;;;1067   
;;;1068       /* Wait till PLL is ready */
;;;1069       while((RCC->CR & RCC_CR_PLLRDY) == 0)
000084  6801              LDR      r1,[r0,#0]
000086  0189              LSLS     r1,r1,#6
000088  d5fc              BPL      |L2.132|
;;;1070       {
;;;1071       }
;;;1072       
;;;1073       /* Select PLL as system clock source */
;;;1074       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
00008a  6841              LDR      r1,[r0,#4]
00008c  f0210103          BIC      r1,r1,#3
000090  6041              STR      r1,[r0,#4]
;;;1075       RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
000092  6841              LDR      r1,[r0,#4]
000094  f0410102          ORR      r1,r1,#2
000098  6041              STR      r1,[r0,#4]
                  |L2.154|
;;;1076   
;;;1077       /* Wait till PLL is used as system clock source */
;;;1078       while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
00009a  6841              LDR      r1,[r0,#4]
00009c  f3c10181          UBFX     r1,r1,#2,#2
0000a0  2902              CMP      r1,#2
0000a2  d1fa              BNE      |L2.154|
                  |L2.164|
;;;1079       {
;;;1080       }
;;;1081     }
;;;1082     else
;;;1083     { /* If HSE fails to start-up, the application will have wrong clock 
;;;1084            configuration. User can add here some code to deal with this error */
;;;1085     }
;;;1086   }
0000a4  bd0c              POP      {r2,r3,pc}
;;;1087   #endif
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
                          DCD      0x40021000
                  |L2.172|
                          DCD      0x40022000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;311      */
;;;312    void SystemCoreClockUpdate (void)
000000  b510              PUSH     {r4,lr}
;;;313    {
;;;314      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
;;;315    
;;;316    #ifdef  STM32F10X_CL
;;;317      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;318    #endif /* STM32F10X_CL */
;;;319    
;;;320    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;321      uint32_t prediv1factor = 0;
;;;322    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;323        
;;;324      /* Get SYSCLK source -------------------------------------------------------*/
;;;325      tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  4a1a              LDR      r2,|L3.108|
000004  6850              LDR      r0,[r2,#4]
000006  f000010c          AND      r1,r0,#0xc
;;;326      
;;;327      switch (tmp)
;;;328      {
;;;329        case 0x00:  /* HSI used as system clock */
;;;330          SystemCoreClock = HSI_VALUE;
00000a  4b19              LDR      r3,|L3.112|
00000c  4819              LDR      r0,|L3.116|
00000e  2900              CMP      r1,#0                 ;327
000010  d00e              BEQ      |L3.48|
000012  2904              CMP      r1,#4                 ;327
000014  d00e              BEQ      |L3.52|
000016  2908              CMP      r1,#8                 ;327
000018  d00e              BEQ      |L3.56|
;;;331          break;
;;;332        case 0x04:  /* HSE used as system clock */
;;;333          SystemCoreClock = HSE_VALUE;
;;;334          break;
;;;335        case 0x08:  /* PLL used as system clock */
;;;336    
;;;337          /* Get PLL clock source and multiplication factor ----------------------*/
;;;338          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
;;;339          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
;;;340          
;;;341    #ifndef STM32F10X_CL      
;;;342          pllmull = ( pllmull >> 18) + 2;
;;;343          
;;;344          if (pllsource == 0x00)
;;;345          {
;;;346            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;347            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;348          }
;;;349          else
;;;350          {
;;;351     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;352           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;353           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;354           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;355     #else
;;;356            /* HSE selected as PLL clock entry */
;;;357            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
;;;358            {/* HSE oscillator clock divided by 2 */
;;;359              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
;;;360            }
;;;361            else
;;;362            {
;;;363              SystemCoreClock = HSE_VALUE * pllmull;
;;;364            }
;;;365     #endif
;;;366          }
;;;367    #else
;;;368          pllmull = pllmull >> 18;
;;;369          
;;;370          if (pllmull != 0x0D)
;;;371          {
;;;372             pllmull += 2;
;;;373          }
;;;374          else
;;;375          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;376            pllmull = 13 / 2; 
;;;377          }
;;;378                
;;;379          if (pllsource == 0x00)
;;;380          {
;;;381            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;382            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;383          }
;;;384          else
;;;385          {/* PREDIV1 selected as PLL clock entry */
;;;386            
;;;387            /* Get PREDIV1 clock source and division factor */
;;;388            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;389            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;390            
;;;391            if (prediv1source == 0)
;;;392            { 
;;;393              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;394              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;395            }
;;;396            else
;;;397            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;398              
;;;399              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;400              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;401              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;402              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;403            }
;;;404          }
;;;405    #endif /* STM32F10X_CL */ 
;;;406          break;
;;;407    
;;;408        default:
;;;409          SystemCoreClock = HSI_VALUE;
00001a  6003              STR      r3,[r0,#0]  ; SystemCoreClock
                  |L3.28|
;;;410          break;
;;;411      }
;;;412      
;;;413      /* Compute HCLK clock frequency ----------------*/
;;;414      /* Get HCLK prescaler */
;;;415      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
00001c  6851              LDR      r1,[r2,#4]
00001e  4a15              LDR      r2,|L3.116|
000020  f3c11103          UBFX     r1,r1,#4,#4
000024  1d12              ADDS     r2,r2,#4
000026  5c51              LDRB     r1,[r2,r1]
;;;416      /* HCLK clock frequency */
;;;417      SystemCoreClock >>= tmp;  
000028  6802              LDR      r2,[r0,#0]  ; SystemCoreClock
00002a  40ca              LSRS     r2,r2,r1
00002c  6002              STR      r2,[r0,#0]  ; SystemCoreClock
;;;418    }
00002e  bd10              POP      {r4,pc}
                  |L3.48|
000030  6003              STR      r3,[r0,#0]            ;330  ; SystemCoreClock
000032  e7f3              B        |L3.28|
                  |L3.52|
000034  6003              STR      r3,[r0,#0]            ;333  ; SystemCoreClock
000036  e7f1              B        |L3.28|
                  |L3.56|
000038  6851              LDR      r1,[r2,#4]            ;338
00003a  f4011170          AND      r1,r1,#0x3c0000       ;338
00003e  6853              LDR      r3,[r2,#4]            ;339
000040  f4033380          AND      r3,r3,#0x10000        ;339
000044  2402              MOVS     r4,#2                 ;342
000046  eb044191          ADD      r1,r4,r1,LSR #18      ;342
00004a  b133              CBZ      r3,|L3.90|
00004c  6853              LDR      r3,[r2,#4]            ;357
00004e  039b              LSLS     r3,r3,#14             ;357
000050  d507              BPL      |L3.98|
000052  4b09              LDR      r3,|L3.120|
000054  4359              MULS     r1,r3,r1              ;359
000056  6001              STR      r1,[r0,#0]            ;359  ; SystemCoreClock
000058  e7e0              B        |L3.28|
                  |L3.90|
00005a  4b07              LDR      r3,|L3.120|
00005c  4359              MULS     r1,r3,r1              ;347
00005e  6001              STR      r1,[r0,#0]            ;347  ; SystemCoreClock
000060  e7dc              B        |L3.28|
                  |L3.98|
000062  4b03              LDR      r3,|L3.112|
000064  4359              MULS     r1,r3,r1              ;363
000066  6001              STR      r1,[r0,#0]            ;363  ; SystemCoreClock
000068  e7d8              B        |L3.28|
;;;419    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      0x40021000
                  |L3.112|
                          DCD      0x007a1200
                  |L3.116|
                          DCD      ||.data||
                  |L3.120|
                          DCD      0x003d0900

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;217      */
;;;218    void SystemInit (void)
000000  b510              PUSH     {r4,lr}
;;;219    {
;;;220      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;221      /* Set HSION bit */
;;;222      RCC->CR |= (uint32_t)0x00000001;
000002  480f              LDR      r0,|L4.64|
000004  6801              LDR      r1,[r0,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  6001              STR      r1,[r0,#0]
;;;223    
;;;224      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;225    #ifndef STM32F10X_CL
;;;226      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  6841              LDR      r1,[r0,#4]
00000e  4a0d              LDR      r2,|L4.68|
000010  4011              ANDS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;227    #else
;;;228      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;229    #endif /* STM32F10X_CL */   
;;;230      
;;;231      /* Reset HSEON, CSSON and PLLON bits */
;;;232      RCC->CR &= (uint32_t)0xFEF6FFFF;
000014  6801              LDR      r1,[r0,#0]
000016  4a0c              LDR      r2,|L4.72|
000018  4011              ANDS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;233    
;;;234      /* Reset HSEBYP bit */
;;;235      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001c  6801              LDR      r1,[r0,#0]
00001e  f4212180          BIC      r1,r1,#0x40000
000022  6001              STR      r1,[r0,#0]
;;;236    
;;;237      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;238      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000024  6841              LDR      r1,[r0,#4]
000026  f42101fe          BIC      r1,r1,#0x7f0000
00002a  6041              STR      r1,[r0,#4]
;;;239    
;;;240    #ifdef STM32F10X_CL
;;;241      /* Reset PLL2ON and PLL3ON bits */
;;;242      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;243    
;;;244      /* Disable all interrupts and clear pending bits  */
;;;245      RCC->CIR = 0x00FF0000;
;;;246    
;;;247      /* Reset CFGR2 register */
;;;248      RCC->CFGR2 = 0x00000000;
;;;249    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;250      /* Disable all interrupts and clear pending bits  */
;;;251      RCC->CIR = 0x009F0000;
;;;252    
;;;253      /* Reset CFGR2 register */
;;;254      RCC->CFGR2 = 0x00000000;      
;;;255    #else
;;;256      /* Disable all interrupts and clear pending bits  */
;;;257      RCC->CIR = 0x009F0000;
00002c  f44f011f          MOV      r1,#0x9f0000
000030  6081              STR      r1,[r0,#8]
;;;258    #endif /* STM32F10X_CL */
;;;259        
;;;260    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;261      #ifdef DATA_IN_ExtSRAM
;;;262        SystemInit_ExtMemCtl(); 
;;;263      #endif /* DATA_IN_ExtSRAM */
;;;264    #endif 
;;;265    
;;;266      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;267      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;268      SetSysClock();
000032  f7fffffe          BL       SetSysClock
;;;269    
;;;270    #ifdef VECT_TAB_SRAM
;;;271      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;272    #else
;;;273      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
000036  4905              LDR      r1,|L4.76|
000038  f04f6000          MOV      r0,#0x8000000
00003c  6008              STR      r0,[r1,#0]
;;;274    #endif 
;;;275    }
00003e  bd10              POP      {r4,pc}
;;;276    
                          ENDP

                  |L4.64|
                          DCD      0x40021000
                  |L4.68|
                          DCD      0xf8ff0000
                  |L4.72|
                          DCD      0xfef6ffff
                  |L4.76|
                          DCD      0xe000ed08

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\system_stm32f10x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_system_stm32f10x_c_5d646a67____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REVSH|
#line 128
|__asm___18_system_stm32f10x_c_5d646a67____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
